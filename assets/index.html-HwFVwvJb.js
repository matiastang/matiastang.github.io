import{_ as t,c as r,a,o}from"./app-CS9K37Kg.js";const n={};function i(p,e){return o(),r("div",null,e[0]||(e[0]=[a('<h1 id="深浅拷贝" tabindex="-1"><a class="header-anchor" href="#深浅拷贝"><span>深浅拷贝</span></a></h1><p>深拷贝：</p><p>深拷贝拷贝多层，每一级别的是数据都会拷贝（内部开辟了新的内存空间进行存储）</p><p>可以拆分为两步：浅拷贝 + 递归，所以循环赋值配合递归也能实现，除此之外：</p><p>for...in遍历并递归。（注意：如果使用Symbol值作为对象的属性名，这个属性通过for...in是无法拿到的，而且通过Objec.keys()方法也是获取不到Symbol属性名的，如果通过JSON.stringfy()去序列化对象为一个JSON字符串的话，Symbol属性也会被忽略掉）</p><p>因此我们还可以使用解构配合Object对象里面getOwnPropertySymbols()方法或者ES6的Reflect.ownKeys(obj)递归实现深拷贝</p><p>// 不考虑 symbol，考虑可新增查找遍历处理的逻辑</p><p>// 第一种 var deepCopy = function(obj) { if (typeof obj !== &#39;object&#39;) return var newObj = obj instanceof Array ? [] : {} for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === &#39;object&#39; ? deepCopy(obj[key]) : obj[key] } } return newObj }</p><p>// 第二种 obj2 = JSON.parse(JSON.stringify(obj)) 浅拷贝：</p><p>Object.assign() // ES6+</p><p>Array.from(arrayLike) // ES6+ 将一个类数组对象或可遍历对象转换为真正数组</p><p>...展开spread // ES6适合数组 ES2018适合对象</p>',12)]))}const c=t(n,[["render",i],["__file","index.html.vue"]]),l=JSON.parse('{"path":"/article/581u0l2e/","title":"深浅拷贝","lang":"zh-CN","frontmatter":{"title":"深浅拷贝","createTime":"2025/01/21 15:07:46","permalink":"/article/581u0l2e/","watermark":true},"headers":[],"readingTime":{"minutes":1.11,"words":334},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/interview/深浅拷贝.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"fe1bf4","sort":10002,"name":"interview"}],"bulletin":false}');export{c as comp,l as data};
