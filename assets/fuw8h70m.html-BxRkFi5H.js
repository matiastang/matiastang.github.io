import{_ as l,c as r,b as e,o as a}from"./app-CS9K37Kg.js";const s={};function o(n,t){return a(),r("div",null,t[0]||(t[0]=[e("h1",{id:"grpc",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#grpc"},[e("span",null,"gRPC")])],-1),e("p",null,"gRPC 支持定义四种服务方法：",-1),e("ul",null,[e("li",null,"一元（unary）RPC，客户端向服务端发送单个请求，取回单个响应，就像普通的函数调用一样。 rpc SayHello(HelloRequest) returns (HelloResponse);"),e("li",null,"服务端流 RPC，客户端向服务端发送一个请求，取回用于读取消息序列的流。客户端从返回的流中读取，直到没有更多消息。gRPC 保证单个 RPC 调用中的消息顺序。 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);"),e("li",null,"客户端流 RPC，客户端写消息序列，再使用提供的流，将它们发送到服务端。一旦客户端完成写消息，它等待服务端读消息，返回响应。gRPC 再次保证单个 RPC 调用中的消息顺序。 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);"),e("li",null,"双向流 RPC，两侧都使用读-写流发送消息序列。这两个流独立运行，因此客户端和服务端可以按照它们喜欢的任何顺序进行读写：比如，服务端可以在写入响应之前等待接收所有客户端消息，或者交替地读消息，然后写消息，或者执行某些其它读写组合。每个流中的消息顺序保持不变。 rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);")],-1)]))}const m=l(s,[["render",o],["__file","fuw8h70m.html.vue"]]),u=JSON.parse('{"path":"/article/fuw8h70m.html","title":"gRPC","lang":"zh-CN","frontmatter":{"title":"gRPC","createTime":"2025/01/20 18:47:25","permalink":"/article/fuw8h70m.html","watermark":true},"headers":[],"readingTime":{"minutes":1.16,"words":347},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/back/gRPC.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"7b2314","sort":10019,"name":"back"}],"bulletin":false}');export{m as comp,u as data};
