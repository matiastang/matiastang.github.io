import{_ as a,c as s,a as n,o as e}from"./app-CS9K37Kg.js";const l={};function t(r,i){return e(),s("div",null,i[0]||(i[0]=[n(`<h1 id="qiankun" tabindex="-1"><a class="header-anchor" href="#qiankun"><span>qiankun</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>官网如下介绍<code>qiankun</code>：</p><ul><li>简单：任意 js 框架均可使用。微应用接入像使用接入一个 iframe 系统一样简单，但实际不是 iframe。</li><li>完备：几乎包含所有构建微前端系统时所需要的基本能力，如 样式隔离、js 沙箱、预加载等。</li><li>生产可用： 已在蚂蚁内外经受过足够大量的线上系统的考验及打磨，健壮性值得信赖。</li></ul><h2 id="安装" tabindex="-1"><a class="header-anchor" href="#安装"><span>安装</span></a></h2><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> yarn</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> add</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> qiankun</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  # or npm i qiankun -S</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>qiankun 使用 import-html-entry 插件将子应用的 html 作为入口，框架会将 HTML document 作为子节点塞到主框架的容器中。就算子应用更新了，其入口 html 文件的 url 始终不会变，并且完整的包含了所有的初始化资源 url，所以不用再自行维护子应用的资源列表了。并且对旧有的项目作为子应用接入成本几乎为零，开发体验与独立开发时保持不变，相较于 single-spa 的 js entry 而言更加灵活、方便、体验更好。</p><p>原理基于 single-spa 将路由切换与子应用加载、卸载等生命周期结合起来是微前端的一项核心能力。这一步 qiankun 是基于 single-spa 实现的，不同的是它支持以 html 作为加载子应用的入口，不必像 single-spa 那样需要手动梳理资源链接，内部插件 import-html-entry 会自动分析 html 以获取 js 和 css。</p><h3 id="样式隔离" tabindex="-1"><a class="header-anchor" href="#样式隔离"><span>样式隔离</span></a></h3><p>为了确保子应用之间样式互不影响，qiankun 内置了三种样式隔离模式：</p><ol><li>默认模式</li></ol><p>原理是加载下一个子应用时，将上一个子应用的 <link rel="stylesheet" href="xxx.css">、 等样式相关标签通通删除与替换，来实现样式隔离。<strong>缺点是仅支持单例模式（同一时间只能渲染单个子应用）,且没法做到主子应用及多个子应用之间的样式隔离</strong>。</p><ol start="2"><li>严格模式</li></ol><p>可通过 strictStyleIsolation：true 开启。原理是利用 webComponent 的 shadowDOM 实现。但它的问题在于隔离效果太好了，在目前的前端生态中有点水土不服，这里举两个例子。</p><ul><li>可能会影响 React 事件</li></ul><p>比如这个issue 当 Shadow Dom 遇上 React 事件[5] ，大致原因是在 React 中事件是“合成事件”，在React 17 版本之前，所有用户事件都需要冒泡到 document 上，由 React 做统一分发与处理，如果冒泡的过程中碰到 shadowRoot 节点，就会将事件拦截在 shadowRoot 范围内，此时event.target 强制指向 shadowRoot，导致在 react 中事件无响应。React 17 之后事件监听位置由 document 改为了挂载 App 组件的 root 节点，就不存在此问题了。</p><ul><li>弹框样式丢失</li></ul><p>原因是主流UI框架比如 antd 为了避免上层元素的样式影响，通常会把弹框相关的 DOM 通过 document.body.appendChild 插入到顶层 body 的下边。此时子应用中 antd 的样式规则，由于开启了 shadowDom ，只对其下层的元素产生影响，自然就对全局 body 下的弹框不起作用了，造成了样式丢失的问题。 解决方案：调整 antd 入参，让其在当前位置渲染。</p><ol start="3"><li>实验模式</li></ol><p>可通过 experimentalStyleIsolation：true 开启。原理类似于 vue 的 scope-css，给子应用的所有样式规则增加一个特殊的属性选择器，限定其影响范围，达到样式隔离的目的。但由于需要在运行时替换子应用中所有的样式规则，所以目前性能较差，处于实验阶段。</p><h3 id="js沙箱" tabindex="-1"><a class="header-anchor" href="#js沙箱"><span>js沙箱</span></a></h3><p>确保子应用之间的“全局变量”不会产生冲突。</p><ol><li>快照沙箱（ snapshotSandbox）</li></ol><ul><li>激活子应用时，对着当前 window 对象照一张相（所有属性 copy 到一个新对象 windowSnapshot 中保存起来）。</li><li>离开子应用时，再对着 window 照一张相，对比离开时的 window 与激活时的 window （也就是 windowSnapshot ）之间的差异。 记录变更。Diff 出在这期间更改了哪些属性，记录在 modifyPropsMap 对象中。 恢复环境。依靠 windowSnapshot 恢复之前的 window 环境。</li><li>下次激活子应用时，从 modifyPropsMap 对象中恢复上一次的变更。</li></ul><ol start="2"><li>单例的代理沙箱 （ LegacySanbox**）</li></ol><p>与快照沙箱思路很相似，但它不用通过 Diff 前后 window 的方式去记录变更，而是通过 ES6的 Proxy 代理 window 属性的 set 操作来记录变更。由于不用反复遍历 window，所以性能要比快照沙箱好。</p><ol start="3"><li>支持多例的代理沙箱（ ProxySandbox）</li></ol><p>以上两种沙箱机制，都只支持单例模式（同一页面只支持渲染单个子应用）。</p><p>原因是：它们都直接操作的是全局唯一的 window。此时机智的你肯定想到了，假如为每个子应用都分配一个独立的“虚拟window”，当子应用操作 window 时，其实是在各自的“虚拟 window”上操作，不就可以实现多实例共存了？事实上，qiankun 确实也是这样做的。</p><p>既然是“代理”沙箱，那“代理”在这的作用是什么呢？ 主要是为了实现对全局对象属性 get、set 的两级查找，优先使用fakeWindow，特殊情况(set命中白名单或者get到原生属性)才会改变全局真实window。 如此，qiankun 就对子应用中全局变量的 get 、 set 都实现了管控与隔离。</p><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li><p>具有先发优势 2019年开源，是国内最早流行起来的微前端框架，在蚂蚁内外都有丰富的应用，后期维护性是可预测的。</p></li><li><p>开箱即用 虽然是基于国外的 single-spa 二次封装，但提供了更加开箱即用的 API，比如支持直接以 HTML 地址作为加载子应用的入口。</p></li><li><p>对 umi 用户更加友好 有现成的插件 @umijs/plugin-qiankun 帮助降低子应用接入成本。</p></li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li>vite 支持性差 由上可知，代理沙箱实现的关键是需要将子应用的 window “替换”为 fakeWindow，在这一步 qiankun 是通过函数 window 同名参数 + with 作用域绑定的方式，更改子应用 window 指向为 fakeWindow，最终使用 eval(...) 解析运行子应用的代码。</li></ul><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> jsCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> \`</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">(function(window, self, globalThis){</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">    with(this){</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      // your code</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      window.a = 1;</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      b = 2</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">      ...</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> }</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">\`</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">eval</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">jsCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题就出在这个 eval 上， vite 的构建产物如果不做特殊降级，默认打包出的就是 ESModule 语法的代码，使用 eval 解析运行会报错。报错的大意是， import 语法的代码必须放在 中执行。</p><p>因为esm的机制导致qiankun没法把js拿来做手动evaluate，因为要支持沙箱。</p><p>官方目前推荐的解决方法是关闭沙箱... 但其实还有另一种比较取巧的方案：vite 生态里有一款专门兼容此问题的vite-plugin-qiankun[11] 插件，它的原理是：eval 虽然没办法执行静态 import 语法，但它可以执行动态 import(...) 语法。</p><p>所以这款插件的解决方案就是替换子应用代码中的静态 import 为动态 import()，以绕过上述限制。</p><ul><li><p>子应用接入成本较高。<a href="https://qiankun.umijs.org/zh/guide/getting-started#%E5%BE%AE%E5%BA%94%E7%94%A8" target="_blank" rel="noopener noreferrer">子应用接入</a> umi 用户可忽略这点，尤其是 @umi/max 用户，相比 webpack 接入成本要低很多。</p></li><li><p>JS 沙箱存在性能问题，且并不完善。 大致原因是 with + proxy 带来的性能损耗，详见 <a href="https://juejin.cn/post/7290138730093461561?searchId=202311202235448D9046EE94B7E42DAC68#heading-3" target="_blank" rel="noopener noreferrer">JS沙箱的困境</a> 。当然 qiankun 官方也在针对性的进行优化，进展在这篇<a href="https://www.yuque.com/kuitos/gky7yw/gs4okg" target="_blank" rel="noopener noreferrer">《改了 3 个字符，10倍的沙箱性能提升？！！》</a>文章中可见一斑 。</p></li></ul><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener noreferrer">qiankun</a></li><li><a href="https://juejin.cn/post/7309477710523269174" target="_blank" rel="noopener noreferrer">三大微前端框架，谁是你的理想型？</a></li><li><a href="https://blog.csdn.net/xgangzai/article/details/135944214" target="_blank" rel="noopener noreferrer">主流微前端框架对比</a></li></ul>`,45)]))}const o=a(l,[["render",t],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/article/dhbzk2gr/","title":"qiankun","lang":"zh-CN","frontmatter":{"title":"qiankun","createTime":"2025/01/21 15:17:04","permalink":"/article/dhbzk2gr/","watermark":true},"headers":[],"readingTime":{"minutes":6.88,"words":2065},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/framework/microfront/qiankun.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"b81acd","sort":10061,"name":"framework"},{"id":"c01b75","sort":10062,"name":"microfront"}],"bulletin":false}');export{o as comp,d as data};
