import{_ as i,c as a,a as e,o as n}from"./app-CS9K37Kg.js";const t="/notes/docker/Docker%E7%BD%91%E7%BB%9C.jpg",l="/notes/docker/macvlan.jpg",h="/notes/docker/Flannel.jpg",r="/notes/docker/Calico.jpg",d={};function o(p,s){return n(),a("div",null,s[0]||(s[0]=[e('<p><img src="'+t+'" alt="Docker网络"></p><p>Docker的网络模式，主要分为两大类：</p><ul><li>主机内网络模式</li><li>主机外网络模式</li></ul><h2 id="主机内网络模式" tabindex="-1"><a class="header-anchor" href="#主机内网络模式"><span>主机内网络模式</span></a></h2><p>当使用docker run创建Docker容器时，可以用–net选项指定容器的网络模式，docker有 <code>host</code>、<code>container</code>、<code>none</code>、<code>bridge</code> 等4种网络模式。</p><h3 id="host-模式" tabindex="-1"><a class="header-anchor" href="#host-模式"><span>host 模式</span></a></h3><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 NAT，host 最大的优势就是网络性能比较好，但是 docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p><h3 id="bridge-模式" tabindex="-1"><a class="header-anchor" href="#bridge-模式"><span>bridge 模式</span></a></h3><p>当 Docker 进程启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从 docker0 子网中分配一个IP给容器使用，并设置 docker0 的IP地址为容器的默认网关。在主机上创建一对虚拟网卡 veth pair 设备，Docker将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0（容器的网卡），另一端放在主机中，以 vethxxx 这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。bridge 模式是 docker 的默认网络模式，不写 --net 参数，就是 bridge 模式。使用docker run -p 时，docker 实际是在 iptables 做了 DNAT 规则，实现端口转发功能。可以使用 iptables -t nat -vnL查看。</p><h3 id="container-模式" tabindex="-1"><a class="header-anchor" href="#container-模式"><span>container 模式</span></a></h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><h3 id="none-模式" tabindex="-1"><a class="header-anchor" href="#none-模式"><span>none 模式</span></a></h3><p>使用none模式，Docker容器拥有自己的 Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个 Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。这种网络模式下容器只有 lo 回环网络，没有其他网卡。none 模式可以在容器创建时通过 --network=none 来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p><h3 id="跨主机网络模式" tabindex="-1"><a class="header-anchor" href="#跨主机网络模式"><span>跨主机网络模式</span></a></h3><p>上述四种主机内网络模式都是针对宿主机与其中的容器进行通信的，并不涉及跨宿主机的网络通信，起初开发 docker 时也没有过多考虑这方面，如果希望跨主机通信，一般有几种方法：</p><ul><li>bridge 端口映射，直接把容器的服务端口映射到主机上，主机直接通过映射出来的端口通信。</li><li>host 模式，但有端口冲突。</li><li>SDN方案：原生overlay、第三方方案：<code>flannel</code>、<code>calico</code>、<code>weaved</code>等等。</li><li>macvlan。</li></ul><h3 id="macvlan" tabindex="-1"><a class="header-anchor" href="#macvlan"><span>macvlan</span></a></h3><p>macvlan 是一种网卡虚拟化技术，将一张物理网卡虚拟化出多个网卡，每个都用独立的mac地址和ip地址。</p><p><img src="'+l+'" alt="macvlan"></p><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4><p>性能好，macvlan 不需要创建 linux bridge，数据包直接通过物理网卡出去。</p><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ul><li>vlan 子接口和需要提前划出来，ip 地址使用需要自己手动去配置。</li><li>vlan 数量有限，不适合大型公有云应用。</li><li>Macvlan 的缺点是需要将主机网卡（NIC）设置为混杂模式（Promiscuous Mode），这在大部分公有云平台上是不允许的。</li></ul><h3 id="flannel" tabindex="-1"><a class="header-anchor" href="#flannel"><span>Flannel</span></a></h3><p>Flannel 是一种基于 overlay 网络的跨主机容器网络解决方案，将 TCP 数据包封装在另一种网络包里面进行路由转发和通信，其中数据包转发需要注册中心。 <code>10.1.15.2</code> 想访问 <code>10.1.20.2</code>，数据包从容器中发出后，宿主机从注册中心查找到 <code>10.1.20.2</code> 在 <code>174.24.8.112</code> 上，用 udp 协议重新封装数据包发给<code>174.24.8.112</code>。</p><p><img src="'+h+'" alt="Flannel"></p><h3 id="calico" tabindex="-1"><a class="header-anchor" href="#calico"><span>Calico</span></a></h3><p><img src="'+r+'" alt="Calico"></p><p>在主机1上设置docker内部流量到docker0的规则</p><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">iptables</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -t</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> nat</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -I</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> PREROUTING</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -s</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.128.0/24</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.129.0/24</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -j</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> DNAT</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --to</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10.0.128.1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>主机1上添加路由，发送到主机2中docker容器（10.0.129.0/24）的数据包先发送到主机2上</p><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">route</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> add</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -net</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.129.0/24</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> gw</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 192.168.91.129</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在主机2上设置docker内部流量到docker0的规则</p><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">iptables</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -t</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> nat</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -I</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> PREROUTING</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -s</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.129.0/24</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.128.0/24</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -j</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> DNAT</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --to</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10.0.129.1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>同理主机2上也添加类型的路由</p><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">route</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> add</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -net</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 10.0.128.0/24</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> gw</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 192.168.91.128</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>解决跨主机通信，总体来看要考虑几方面：</p><ul><li>是否支持公有云、私有云多租户隔离。</li><li>是否简单易实施。</li><li>转发性能。</li></ul>',39)]))}const k=i(d,[["render",o],["__file","qnifq7eo.html.vue"]]),g=JSON.parse('{"path":"/docker/qnifq7eo.html","title":"Docker 网络","lang":"zh-CN","frontmatter":{"title":"Docker 网络","createTime":"2025/03/11 16:57:48","permalink":"/docker/qnifq7eo.html","watermark":true},"headers":[],"readingTime":{"minutes":4.74,"words":1421},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/docker/Docker网络.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"154f33","sort":10010,"name":"docker"}],"bulletin":false}');export{k as comp,g as data};
