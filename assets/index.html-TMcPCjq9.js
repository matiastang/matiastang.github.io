import{_ as e}from"./micro-app的js沙箱-fLfB_w8s.js";import{_ as i,c as n,a as r,o as p}from"./app-CS9K37Kg.js";const l="/framework/microfront/%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88.jpg",s={};function t(o,a){return p(),n("div",null,a[0]||(a[0]=[r('<h1 id="微前端" tabindex="-1"><a class="header-anchor" href="#微前端"><span>微前端</span></a></h1><h2 id="前端架构发展史" tabindex="-1"><a class="header-anchor" href="#前端架构发展史"><span>前端架构发展史</span></a></h2><p>最初，前端是没有架构的，因为功能简单的代码没有架构可言。通过操作DOM就能完成的工作，不需要复杂的设计模式和代码管理机制，也就不需要架构来支撑起应用。前端开发的发展历史分为以下几个阶段：</p><p>◎ 古典时期。由后端渲染出前端HTML，用Table布局，用CSS进行简单的辅助。 ◎ 动效时期。前端开始编写一些简单的JavaScript脚本来做动画效果，如轮播广告。 ◎ Ajax异步通信时期。2005年，Google在诸多Web应用中使用了异步通信技术如Google地图，开启了Web前端的一个新时代。</p><p>一旦前端应用需要从后端获取数据，就意味着前端应用在运行时是动态地渲染内容的，这便是Model（模型）UI层解耦。jQuery能够提供DOM操作方法和模板引擎等。这时的开发人员需要做下面两个事情：</p><p>◎ 动态生成HTML。由后端返回前端所需要的HTML，再动态替换页面的DOM元素。早期的典型架构如jQuery Mobile，事先在前端写好模板与渲染逻辑，用户的行为触发后台并返回对应的数据，来渲染文件。 ◎ 模板分离。由后端用API返回前端所需要的JSON数据，再由前端来计算生成这些HTML。前端的模板不再使用HTML，而是使用诸如Mustache这样的模板引擎来渲染HTML。</p><p>由于HTML的动态生成、模板的独立与分离，前端应用开始变得复杂。后端的MVC架构进一步影响了前端开发，便诞生了一系列早期的MVC框架，如Backbone,Knockout，等等。与此同时，在Ryan Lienhart Dahl等人开发了Node.js之后，前端的软件工程便不断地改善：</p><p>◎ 更好的构建工具。诞生了诸如Grunt和Gulp等构建工具。 ◎ 包管理。产生了用于前端的包管理工具Bower和NPM。 ◎ 模块管理。也出现了AMD、Common.js等不同的模块管理方案。</p><p>随着单页面应用的流行，前后端分离架构也成为行业内的标准实践。由此，前端进入了一个新的时代，要考虑的内容也越来越多：</p><p>◎ API管理，采用了诸如Swagger的API管理工具，各式的Mock Server也成为标准实践。 ◎ 大前端，由前端来开发跨平台移动应用框架，采用诸如Ionic、React Native、Flutter等框架。 ◎ 组件化，前端应用从此由一个个细小的组件结合而成，而不再是一个大的页面组件。</p><p>系统变得越来越复杂，架构在前端的作用也变得越来越重要。MVC满足不了开发人员的需求，于是采用了组件化架构。而组件化+MV*也无法应对大型的前端应用，微前端便又出现在我们的面前，它解决了以下问题：</p><p>◎ 跨框架。在一个页面上运行，可以同时使用多个前端框架。 ◎ 应用拆分。将一个复杂的应用拆解为多个微小的应用，类似于微服务。 ◎ 遗留系统迁移。让旧的前端框架，可以直接嵌入现有的应用运行。</p><p>复杂的前端应用发展了这么久，也出现了一系列需要演进的应用——考虑重写、迁移、重构，等等。</p><h2 id="微前端-1" tabindex="-1"><a class="header-anchor" href="#微前端-1"><span>微前端</span></a></h2><p>微前端是指存在于浏览器中的微服务。</p><p>微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为把多个小型前端应用聚合为一体的应用。这就意味着前端应用的拆分，拆分后的应用实现应用自治、单一职责、技术栈无关三大特性，再进行基座模式或自由组合的模式进行聚合，达到微前端的目的。</p><p>一般来说，微前端需要解决的问题分为两大类：</p><ul><li>应用的加载与切换：路由问题、应用入口、应用加载</li><li>应用的隔离与通信：js隔离、css样式隔离、应用间通信</li></ul><h2 id="微前端方案" tabindex="-1"><a class="header-anchor" href="#微前端方案"><span>微前端方案</span></a></h2><ul><li>路由分发</li><li>iframe</li><li>single-spa</li><li>qiankun</li><li>wujie</li></ul><p><img src="'+l+'" alt="微前端方案"></p><h2 id="主流技术方向分类" tabindex="-1"><a class="header-anchor" href="#主流技术方向分类"><span>主流技术方向分类</span></a></h2><p>按照它们对 iframe 看法的不同，将主流微前端方案分为了三大派系：革新派、改良派、中间派。</p><h3 id="革新派" tabindex="-1"><a class="header-anchor" href="#革新派"><span>革新派</span></a></h3><h4 id="qiankun" tabindex="-1"><a class="header-anchor" href="#qiankun"><span>qiankun</span></a></h4><p>以 qiankun 为主的革新派认为：<code>iframe 问题很多，应避免使用它</code>。 完全可以利用现有的前端技术自建一套应用隔离渲染方案。</p><ul><li>原理基于 single-spa 将路由切换与子应用加载、卸载等生命周期结合起来是微前端的一项核心能力。这一步 qiankun 是基于 single-spa 实现的，不同的是它支持以 html 作为加载子应用的入口，不必像 single-spa 那样需要手动梳理资源链接，内部插件 import-html-entry 会自动分析 html 以获取 js 和 css。</li></ul><h3 id="改良派" tabindex="-1"><a class="header-anchor" href="#改良派"><span>改良派</span></a></h3><h4 id="wujie" tabindex="-1"><a class="header-anchor" href="#wujie"><span>wujie</span></a></h4><p>wujie 是腾讯出品的一款微前端框架。作为改良派的代表，它认为： iframe 虽然问题很多，但仅把它作为一个 js 沙箱去用，表现还是很稳定的，毕竟是浏览器原生实现的，比自己实现 js 沙箱靠谱多了。至于 iframe 的弊端，可以针对性的去优化：</p><p>DOM 渲染无法突破 iframe 边界？(弹框不居中问题)</p><p>那 DOM 就不放 iframe 里渲染了，而是单独提取到一个 webComponent 里渲染，顺便用 shadowDOM 解决样式隔离的问题。 简单说，无界的方案就是：<strong>JS 放 iframe 里运行，DOM 放 webComponent 渲染</strong>。 那么问题来了： 用 JS 操作 DOM 时，两者如何联系起来呢？毕竟 JS 默认操作的总是全局的 DOM。无界在此处用了一种比较 hack 的方式：代理子应用中所有的 DOM 操作，比如将 document 下的 getElementById、querySelector、querySelectorAll、head、body 等查询类 api 全部代理到 webComponent。</p><h3 id="中间派" tabindex="-1"><a class="header-anchor" href="#中间派"><span>中间派</span></a></h3><h4 id="micro-app" tabindex="-1"><a class="header-anchor" href="#micro-app"><span>micro-app</span></a></h4><p>京东的大前端团队出品。</p><ul><li>样式隔离方案与 qiankun 的实验方案类似，也是在运行时给子应用中所有的样式规则增加一个特殊标识来限定 css 作用范围。</li><li>子应用路由同步方案与 wujie 类似，也是通过劫持路由跳转方法，同步记录到 url 的 query 中，刷新时读取并恢复。</li><li>组件化的使用方式与 wujie 方案类似，这也是 micro-app 主打的宣传点。</li><li>最有意思的是它的沙箱方案，居然内置了两种沙箱：</li></ul><ol><li>类 qiankun 的 with 代理沙箱，据说相比 qiankun 性能高点，但目前微前端框架界并没有一个权威的基准性能测试依据，所以并无有效依据支撑。</li><li>类 wujie 的 iframe 沙箱，用于兼容 vite 场景。</li></ol><p>开发者可以根据自身的实际情况自由选择。 整体感觉 micro-app 是一种偏“现实主义”的框架，它的特点就是取各家所长，最终成为了功能最丰富的微前端框架。</p><p><img src="'+e+'" alt="micro-app的js沙箱"></p><h2 id="其他框架" tabindex="-1"><a class="header-anchor" href="#其他框架"><span>其他框架</span></a></h2><ul><li>WebPack 5和模块联合 多个单独的构建应形成单个应用程序。这些单独的构建不应彼此之间有依赖关系，因此可以单独开发和部署它们。La Micro Frontends。</li></ul><p>模块联合是由Zack Jackson发明的JavaScript架构，然后提出为它创建一个WebPack插件。WebPack团队有助于将插件带入WebPack 5，目前在Beta中。</p><p>简而言之，模块联合允许JavaScript应用程序在运行时从另一个应用程序动态导入代码。该模块将构建一个唯一的JavaScript条目文件，可以通过设置WebPack配置来由其他应用程序下载。</p><p>它还通过启用依赖性共享来解决代码依赖关系和增加捆绑大小的问题。例如，如果您正在下载React组件，您的应用程序将不会导入两次React代码。该模块将巧妙地使用您已经拥有的React源，并仅导入组件代码。最后，您可以使用React.Lazy和React.Suspense如果导入的代码出于某种原因，请提供退回，如果出于某种原因，请确保用户体验不会因版本而无法中断。</p><p>这解锁了构建微型前端的一些非常有利的潜力。</p><ul><li>Open Components Open Components项目将其目标宣布为“在前端世界中的无服务架构”。更具体地说，OC旨在成为微前端的框架，它提供了一个地方所需的一切，使其成为一个丰富和复杂的系统，包括从组件处理到注册表到模板甚至CLI工具的工具。OpenComponents有两部分：</li></ul><p>组件是小单位代理代码，主要由HTML，JavaScript，CSS组成。它们可以选择包含一些逻辑，允许服务器端节点.js应用程序撰写用于呈现视图的模型。渲染后，它们是要注入任何HTML页面的纯HTML。</p><p>消费者是网站或微基金(所有由前门服务或任何路由机制连接的小型可部署网站)，需要组件以在其网页中呈现部分内容。</p><ul><li><p>Bit 位允许您从独立组件编写和管理前端。这可能是列表中最受欢迎和最受欢迎的制作的解决方案。</p></li><li><p>Piral. Piral的目标是让您轻松使用微前端构建门户网站应用程序。Piral使您可以创建一个模块化前端应用程序，该应用程序在运行时扩展，其中包含叫灭脱帽的解耦模块，利用了微型前端架构。Pilet可以独立开发，并以必要的代码以及所有其他相关资产。</p></li></ul><p>前提条件相当不错，作为开发人员，您只需要您最喜欢的编辑器，终端，互联网浏览器和Node.js。Piral实例(应用程序shell)和Pilets(应用程序shell)可以在本地开发机上的仿真器中执行和调试。</p><ul><li><p>Luigi是一个微前端JavaScript框架，使您可以创建由本地和分布式视图驱动的管理用户界面。Luigi允许Web应用程序与应用程序包含的微前端通信。要确保通信顺利运行，您可以配置路由，导航，授权和UX元素等设置。</p></li><li><p>FrintJS Frintjs是“模块化JavaScript框架，用于构建可扩展和反应应用程序”。它允许您加载来自单独的Bundlers中的应用程序，为您的应用程序提供一个结构，并处理诸如路由，依赖项等所关注的真实性。该项目还通过其他软件包支持RN和Vue，但它主要记录并测试React。</p></li><li><p>Mosaic</p></li></ul><p>Mosaic是一组服务，库以及一个规范，定义其组件如何相互交互，以支持大规模网站的微服务样式架构。Mosaic使用单独的服务片段，并根据模板定义在运行时组成。</p><p>它由一堆包组成，包括处理不同的问题，例如路由，布局，模板存储甚至展示UI。</p><ul><li>PuzzleJS Puzzlejs是“用于可扩展和快速网站的微前端框架”。它允许您创建彼此交谈的网关和店面项目。它是由Facebook的BigPipe的启发，朝着微观的方向。</li></ul><h2 id="选型" tabindex="-1"><a class="header-anchor" href="#选型"><span>选型</span></a></h2><h3 id="刚性建议。" tabindex="-1"><a class="header-anchor" href="#刚性建议。"><span>刚性建议。</span></a></h3><ul><li>vite 项目且对 js 沙箱有刚需，选 wujie 或者 micro-app。</li><li>项目存在复杂的交互场景，比如有用到富文本编辑器库，选 wujie 前请做好充分的测试。</li><li>如果你的团队对主、子应用的开发完全受控，即使有隔离性问题也可以通过治理来解决，那么可以试试更轻量的 single-SPA 方案。</li><li>如果特别重视稳定性，那无疑是 iframe 最佳... 因为 iframe 存在的问题都是摆在明面的，市面上现有的微前端框架多多少少都有一些隐性问题。</li></ul><h3 id="综合推荐。" tabindex="-1"><a class="header-anchor" href="#综合推荐。"><span>综合推荐。</span></a></h3><p>主要从接入成本、功能稳定性、长期维护性三方面来衡量：</p><ul><li>接入成本： wujie &gt; microApp &gt; qiankun （由低到高）</li><li>功能稳定性：qiankun &gt; microApp &gt; wujie</li><li>长期维护性：qiankun &gt; microApp &gt; wujie</li></ul><p>看你的团队最看重哪一点，针对性去选择就好了，没有十全十美微前端框架，只有适合自己的。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://juejin.cn/post/7309477710523269174" target="_blank" rel="noopener noreferrer">三大微前端框架，谁是你的理想型？</a></li><li><a href="https://blog.csdn.net/xgangzai/article/details/135944214" target="_blank" rel="noopener noreferrer">主流微前端框架对比</a></li></ul>',63)]))}const u=i(s,[["render",t],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/notes/framework/microfront/","title":"微前端","lang":"zh-CN","frontmatter":{"watermark":true},"headers":[],"readingTime":{"minutes":10.89,"words":3266},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/framework/microfront/README.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"b81acd","sort":10061,"name":"framework"},{"id":"c01b75","sort":10062,"name":"microfront"}],"bulletin":false}');export{u as comp,d as data};
