import{_ as a,c as t,a as r,o}from"./app-CS9K37Kg.js";const i={};function n(s,e){return o(),t("div",null,e[0]||(e[0]=[r('<h1 id="wujie" tabindex="-1"><a class="header-anchor" href="#wujie"><span>wujie</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>wujie 是腾讯出品的一款微前端框架 无界：极致的微前端框架 基于 <code>WebComponent</code> 容器 + <code>iframe</code> 沙箱</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p><strong>JS 放 iframe 里运行，DOM 放 webComponent 渲染</strong></p><p>wujie 是腾讯出品的一款微前端框架。作为改良派的代表，它认为： iframe 虽然问题很多，但仅把它作为一个 js 沙箱去用，表现还是很稳定的，毕竟是浏览器原生实现的，比自己实现 js 沙箱靠谱多了。至于 iframe 的弊端，可以针对性的去优化：</p><p>DOM 渲染无法突破 iframe 边界？(弹框不居中问题)</p><p>那 DOM 就不放 iframe 里渲染了，而是单独提取到一个 webComponent 里渲染，顺便用 shadowDOM 解决样式隔离的问题。 简单说，无界的方案就是：<strong>JS 放 iframe 里运行，DOM 放 webComponent 渲染</strong>。 那么问题来了： 用 JS 操作 DOM 时，两者如何联系起来呢？毕竟 JS 默认操作的总是全局的 DOM。无界在此处用了一种比较 hack 的方式：代理子应用中所有的 DOM 操作，比如将 document 下的 getElementById、querySelector、querySelectorAll、head、body 等查询类 api 全部代理到 webComponent。</p><p>至于多实例模式，就更容易理解了。给每个子应用都分配一套 iframe + webComponent 的组合，就可以实现相互之间的隔离了！</p><p>刷新页面会导致子应用路由状态丢失？</p><p>通过重写 iframe 实例的 history.pushState 和 history.replaceState，将子应用的 path 记录到主应用地址栏的 query 参数上，当刷新浏览器初始化 iframe 时，从地址栏读到子应用的 path 并使用 iframe 的 history.replaceState 进行同步。 简单理解就是：将子应用路径记录在地址栏参数中。</p><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li><p>相比 qiankun 接入成本更低。 父应用：与 iframe 的接入方式很类似，只需引入一个 React 组件渲染子应用即可。 子应用理论上不需要做任何改造</p></li><li><p>vite 兼容性好 直接将完整的 ESM 标签块  插入 iframe 中，避免了 qiankun 使用 eval 执行 ESM 代码导致的报错问题。</p></li><li><p>iframe 沙箱隔离性好</p></li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li>明坑： 用于 JS 沙箱的 iframe 的 src 必须指向一个同域地址导致的问题。</li></ul><p><strong>加载完子应用入口html后，还要请求一次煮应用host。</strong> 具体问题描述见下图：</p><p>此 <a href="">issue</a> 至今无法在框架层面得到解决，属于 iframe 的原生限制。</p><p>手动的解决方案： 主应用提供一个路径比如说 https://host/empty ，这个路径不需要返回任何内容，子应用设置 attr 为 {src:&#39;https://host/empty&#39;}，这样 iframe 的 src 就是 https://host/empty。 在主应用 template 的 head 插入 这样的代码可以避免主应用代码污染。</p><ul><li>暗坑： 复杂的 iframe 到 webComponent 的代理机制，导致市面上大部分富文本编辑器都无法在无界中完好运行。所以有富文本的项目，尽量别用无界，除非你对富文本库的源码了如指掌。<a href="https://github.com/Tencent/wujie/issues/479" target="_blank" rel="noopener noreferrer">issues</a> 在这里。</li></ul><p>wangeditor QuillEditor富文本无法正常使用 对于 wangeditor 试试这样写插件：</p><p>plugins: [ { jsBeforeLoaders: [ { content: <code>window.Selection = window.parent.Selection</code>, }, ], jsLoader: (code) =&gt; { return code .replace(&quot;n.isCollapsed&quot;, &quot;n.baseOffset === n.focusOffset&quot;) .replace(&quot;n.collapsed&quot;, &quot;n.startOffset === n.endOffset&quot;); }, }, ], 具体原理： 1、子应用运行在 iframe内，dom在主应用的shadowdom中，当选中文字时，在主应用监听selectionchange，并且通过 document.getSelection()获取选中的selection，在wangEditor中 会判断这个 selection instanceof window.Selection，很明显主应用的selection 不可能是 iframe 里面window Selection的实例，所以干脆将主应用的 Selection赋值给 iframe 的 Selection</p><p>2、shadowDom 大坑，详见 stackoverflow，在shadowDom中 Selection.isCollapsed永远为true，相当于永远没有选中，所以只能修改 wangEditor 的代码，让读取 isCollapsed 修改成 baseOffset 和 focusOffset的对比，就知道是否选中了文字了</p><ul><li>长期维护性一般</li><li>内存开销较大 用于 js 沙箱的 iframe 是隐藏在主应用的 body 下面的，相当于是常驻内存，这可能会带来额外的内存开销。</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://wujie-micro.github.io/doc/" target="_blank" rel="noopener noreferrer">wujie</a></li><li><a href="https://wujie-micro.github.io/doc/guide/" target="_blank" rel="noopener noreferrer">wujie 指南</a></li><li><a href="https://juejin.cn/post/7309477710523269174" target="_blank" rel="noopener noreferrer">三大微前端框架，谁是你的理想型？</a></li></ul>',26)]))}const p=a(i,[["render",n],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/article/3iefaya5/","title":"wujie","lang":"zh-CN","frontmatter":{"title":"wujie","createTime":"2025/01/21 15:17:04","permalink":"/article/3iefaya5/","watermark":true},"headers":[],"readingTime":{"minutes":3.64,"words":1093},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/framework/microfront/wujie.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"b81acd","sort":10061,"name":"framework"},{"id":"c01b75","sort":10062,"name":"microfront"}],"bulletin":false}');export{p as comp,c as data};
