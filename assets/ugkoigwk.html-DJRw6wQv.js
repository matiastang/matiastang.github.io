import{_ as o,c as a,a as t,o as c}from"./app-CS9K37Kg.js";const d={};function i(r,e){return c(),a("div",null,e[0]||(e[0]=[t('<p>浏览器中的 HTTP 缓存机制可以分为两种：一种是需要发送请求（协商缓存），一种是不需要发送请求（强缓存）。</p><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span>强缓存</span></a></h2><p>这个阶段 不需要发送HTTP请求</p><p>在HTTP/1.0使用的是<code>Expires</code> Expires: Wed, 22 Nov 2019 08:41:00 GMT（服务器时间和浏览器时间不一致就不准确）</p><p>而HTTP/1.1使用的是<code>Cache-Control</code> Cache-Control:max-age=3600（<code>no-store</code>不缓存 <code>no-cache</code>跳过强缓存）</p><p>当<code>Expires</code>和<code>Cache-Control</code>同时存在的时候，<code>Cache-Control</code>会优先考虑。</p><p>当资源缓存时间超时，也就是强缓存失效后，就进入到第二级屏障——协商缓存</p><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h2><p>协商缓存：会发送HTTP请求，这样的缓存tag分为两种: <code>Last-Modified</code> 和 <code>ETag</code>。这两者各有优劣</p><p><code>Last-Modified</code> 即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段</p><p>浏览器接收到后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的该文件最后修改时间，服务器拿到请求头中的<code>If-Modified-Since</code>的字段后，会和这个服务器中该资源的最后修改时间对比</p><p><code>ETag</code> 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器，浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器，服务器接收到<code>If-None-Match</code>后，会跟服务器上该资源的ETag进行比对</p><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><p>有些特定的场合下，一些静态的文件，可能会被频繁的更新， 但是文件内容没有变化，这时候如果使用Last-modified，服务器端始终返回最新的内容给浏览器，而Etag是根据文件内容来的，如果内容没有变化的话，始终会让浏览器使用本地缓存的文件。所以，使用ETag可以更好的避免一些不必要的服务器响应。</p><p>缓存位置：若资源更新，返回资源和200状态码，否则，返回304，告诉浏览器直接从缓存获取资源</p><p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p><p>Service Worker：借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM</p><p>Memory Cache：内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，渲染进程结束也就不存在了</p><p>Disk Cache：存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长</p><p>Push Cache：推送缓存，这是浏览器缓存的最后一道防线，它是 HTTP/2 中的内容</p>',20)]))}const p=o(d,[["render",i],["__file","ugkoigwk.html.vue"]]),s=JSON.parse('{"path":"/interview/ugkoigwk.html","title":"HTTP 缓存机制","lang":"zh-CN","frontmatter":{"title":"HTTP 缓存机制","createTime":"2025/01/21 15:07:46","permalink":"/interview/ugkoigwk.html","watermark":true},"headers":[],"readingTime":{"minutes":2.77,"words":832},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/interview/http缓存机制.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"fe1bf4","sort":10002,"name":"interview"}],"bulletin":false}');export{p as comp,s as data};
