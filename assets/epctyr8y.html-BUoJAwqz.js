import{_ as r,c as e,a as n,o as t}from"./app-CS9K37Kg.js";const o={};function s(m,a){return t(),e("div",null,a[0]||(a[0]=[n(`<h1 id="模型框架对比" tabindex="-1"><a class="header-anchor" href="#模型框架对比"><span>模型框架对比</span></a></h1><h2 id="transformer" tabindex="-1"><a class="header-anchor" href="#transformer"><span>Transformer</span></a></h2><p>Transformer架构是一种用于序列建模的深度学习架构，最初由Vaswani等人在2017年提出，并广泛应用于自然语言处理（NLP）任务中。它引入了自注意力机制（self-attention）来捕捉输入序列中元素之间的依赖关系，并在大规模数据集上取得了显著的性能提升。以下是Transformer架构的主要组成部分：</p><p>自注意力机制（Self-Attention）：自注意力机制是Transformer的核心组件之一。它允许模型在输入序列中的每个位置上根据其他位置的信息进行加权聚合。通过计算每个位置与其他位置之间的相对重要性，模型可以更好地理解序列中不同元素之间的依赖关系。</p><p>编码器（Encoder）：编码器是Transformer的基本模块，用于将输入序列转换为上下文感知的表示。编码器由多个相同的层堆叠而成，每个层都包含自注意力机制和前馈神经网络（Feed-Forward Network）。自注意力机制用于捕捉输入序列内部的依赖关系，而前馈神经网络则提供非线性变换和特征映射。</p><p>解码器（Decoder）：解码器也是由多个相同的层堆叠而成，与编码器类似，但还包括额外的自注意力机制层，用于对编码器的输出进行进一步的上下文感知。解码器常用于生成目标序列，如机器翻译任务中将源语言句子翻译成目标语言句子。</p><p>位置编码（Positional Encoding）：由于Transformer中没有使用递归或卷积操作，模型需要一种方式来处理输入序列中的位置信息。位置编码是一种将位置信息嵌入到输入序列中的方法，使模型能够区分不同位置的元素。通常使用正弦和余弦函数生成位置编码。</p><p>多头注意力机制（Multi-Head Attention）：为了增强模型的表达能力和建模能力，Transformer中的自注意力机制被扩展为多个并行的注意力头。每个注意力头可以关注序列中不同的相关性和特征，然后将它们的输出进行拼接或加权平均。</p><pre><code>Transformer架构的突出特点是其并行性和全局视野能力，允许模型在处理长序列任务时保持高效。它在许多NLP任务中取得了巨大成功，如机器翻译、文本生成、问答系统等。同时，Transformer的思想也被广泛应用于其他领域，如计算机视觉和语音处理，取得了显著的成效。
</code></pre><h2 id="mamba" tabindex="-1"><a class="header-anchor" href="#mamba"><span>Mamba</span></a></h2><p>Mamba是一种新的状态空间模型体系结构，在信息密集的数据（如语言建模）上表现出了良好的性能，而以前的次二次模型无法达到Transformers的性能。它基于结构化状态空间模型的发展路线，受到FlashAttention的的启发进行了高效的硬件感知设计和实现。</p><pre><code>尽管基础模型现在为深度学习中大多数令人兴奋的应用程序提供动力，几乎普遍基于Transformer架构及其核心注意力模块。为了以解决Transformers在长序列上的计算效率低下的问题，学者们已经相继开发了许多次二次时间架构，如线性注意力、门控卷积和递归模型以及结构化状态空间模型（SSM），但它们在语言等重要模态上的表现不如关注。作者发现这种模型的一个关键弱点是它们无法执行基于内容的推理，并进行了一些改进。
</code></pre><p>首先，简单地用输入函数来作为SSM参数，就可以用离散模态来解决它们的弱点，允许模型根据当前令牌沿着序列长度维度选择性地传播或忘记信息。</p><p>其次，尽管这种变化阻止了高效卷积的使用，但作者在递归模式下设计了一种硬件感知的并行算法。并将这些选择性SSM集成到一个简化的端到端神经网络架构中，而无需注意力机制，甚至无需MLP块（Mamba）。</p><pre><code>Mamba具有快速推理（比Transformers高5倍的吞吐量）和序列长度的线性缩放，其性能在高达百万长度的真实数据序列上得到了提高。作为通用序列模型的主干，Mamba在语言、音频和基因组学等多种模式中实现了最先进的性能。在语言建模方面，Mamba-3B模型在预训练和下游评估方面都优于相同大小的Transforme rs，并与两倍于其大小的Transformer相匹配。
</code></pre><h2 id="rwkv" tabindex="-1"><a class="header-anchor" href="#rwkv"><span>RWKV</span></a></h2><p>RWKV（发音为RwaKuv）是一种具有GPT级LLM性能的RNN，也可以像GPT转换器一样直接训练（可并行化）。 它结合了RNN和transformer的优点，具有出色的性能、快速推理、快速训练、节省VRAM、“无限”ctxlen和自由文本嵌入。</p><pre><code>作者提出了Eagle（RWKV-5）和Finch（RWKV-6），它们是在RWKV（RWKV-4）架构的基础上改进的序列模型。该架构设计的改进点包括多头矩阵值状态和动态递归机制，它们在保持RNN的推理效率特性的同时提高了表达能力。

除此之外，作者介绍了一个新的多语言语料库，其中包含1.12万亿个标记和一个基于贪婪匹配的快速标记器，以增强多语言性。作者训练了四个Eagle模型，参数从4.6亿到75亿不等，以及两个Finch模型，参数分别为16亿和31亿，发现它们在各种基准中都取得了有竞争力的性能。
</code></pre><p>2020年，OpenAI缩放定律论文表明，LSTM（一种RNN）不能像Transformers那样进行缩放，也不能有效地使用长上下文。</p><pre><code>如上图所示，在左边，我们观察到Mamba，当今最受欢迎的RNN之一，它的规模与强大的Transformer相似，显示出自2020年LSTM以来的巨大进步。然而，在右边，我们观察到Mamba的问题与Kaplan等人对LSTM的问题相同。序列中较晚的令牌平均来说应该更容易预测，因为它们以更多的信息为条件Transfor mer的情况确实如此，其在每个令牌索引处的平均困惑度在整个32k上下文中都会降低。相比之下，Mamba在16k后也出现了同样的指标平稳期。

这个结果代表了现有RNN的尴尬现实。一方面，RNN（与Transformer相比）的主要优点是其线性（与二次型）复杂性。这种渐近优势只有在长上下文的实践中才能实现，长上下文是在8k之后。另一方面，一旦上下文足够长，现有的RNN（如Mamba）就很难真正利用所依赖的额外信息。

长上下文的困难是RNN层固有的，与自我注意力不同，RNN层必须将上下文压缩到固定大小的隐藏状态。作为一种压缩启发式方法，更新规则需要发现数千个或可能数百万个令牌之间的底层结构和关系。在本文中，作者观察到：自监督学习可以将大量训练集压缩为LLM等模型的权重，LLM通常对其训练数据之间的语义连接表现出深刻的理解，这正是我们所需要的。
</code></pre><h3 id="ttt算法" tabindex="-1"><a class="header-anchor" href="#ttt算法"><span>TTT算法</span></a></h3><p>自注意力机制在长上下文中表现良好，但具有二次复杂性。现有的RNN层具有线性复杂性，但它们在长上下文中的性能受到其隐藏状态的表达能力的限制。</p><pre><code>本文作者提出了一类新的序列建模层，它具有线性复杂性和可表达的隐藏状态。关键思想是使隐藏状态本身成为机器学习模型，更新规则成为自监督学习的一个步骤。由于隐藏状态甚至在测试序列上也通过训练来更新，因此该层被称为测试时间训练（TTT）层。

随后，作者考虑了两种实例：TTT-Linear和TTT-MLP，它们的隐藏状态分别是线性模型和两层MLP。作者在125M到1.3B参数的范围内评估这些实例的性能，与强大的Transformer和现代RNN Mamba进行了比较。

大量的实验结果表明：TTT-Linear和TTT-MLP都匹配或超过基线。与Transformer类似，它们可以通过限制更多的代币来不断减少困惑，而Mamba在16k上下文后则不能。经过初步的系统优化，TTT Linear在8k环境下已经比Transformer更快，并且在wall-clock时间上与Mamba相匹配。

然而，TTT-MLP在内存I/O方面仍然面临挑战，但在长上下文情况下显示出更大的潜力，为未来的研究指明了一个有希望的方向。
</code></pre><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://blog.csdn.net/sinat_37574187/article/details/140287124" target="_blank" rel="noopener noreferrer">对比参考</a></p>`,25)]))}const c=r(o,[["render",s],["__file","epctyr8y.html.vue"]]),T=JSON.parse('{"path":"/llm/epctyr8y.html","title":"LLM 模型框架","lang":"zh-CN","frontmatter":{"title":"LLM 模型框架","createTime":"2025/01/20 18:40:17","permalink":"/llm/epctyr8y.html","watermark":true},"headers":[],"readingTime":{"minutes":7.97,"words":2390},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/llm/LLM模型框架.md","bulletin":false}');export{c as comp,T as data};
