import{_ as a,c as n,b as e,o as i}from"./app-CS9K37Kg.js";const r={};function s(o,t){return i(),n("div",null,t[0]||(t[0]=[e("h1",{id:"nexttick-原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#nexttick-原理"},[e("span",null,"nextTick 原理")])],-1),e("p",null,"事件循环机制 nextTick 主要是使用了宏任务和微任务定义了一个异步方法",-1),e("p",null,"首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。 Vue 开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。",-1),e("p",null,"同步任务执行完之后,才会去任务队列中读取回调函数,等待主线程执行,然后更新 dom 如果环境支持,nextTick 内部是用 promise.then,MutationObserver, setImmediate 等 如果环境不支持,采用的 setTimeout 来实现异步",-1)]))}const l=a(r,[["render",s],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/article/z741sznp/","title":"Vue的nextTick","lang":"zh-CN","frontmatter":{"title":"Vue的nextTick","createTime":"2025/01/21 15:07:46","permalink":"/article/z741sznp/","watermark":true},"headers":[],"readingTime":{"minutes":0.76,"words":229},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/interview/Vue的nextTick.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"fe1bf4","sort":10002,"name":"interview"}],"bulletin":false}');export{l as comp,m as data};
