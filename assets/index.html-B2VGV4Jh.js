import{_ as e,c as t,a as n,o as a}from"./app-CS9K37Kg.js";const p={};function r(c,o){return a(),t("div",null,o[0]||(o[0]=[n(`<p>永远不要使用 eval！ eval() 是一个危险的函数，它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，你最终可能会在你的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击。</p><p>eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。</p><p>此外，现代 JavaScript 解释器将 JavaScript 转换为机器代码。这意味着任何变量命名的概念都会被删除。因此，任意一个 eval 的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。另外，新内容将会通过 eval() 引进给变量，比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。但是（谢天谢地）存在一个非常好的 eval 替代方法：只需使用 window.Function。这有个例子方便你了解如何将eval()的使用转变为Function()。</p><p>在计算机安全中,沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制,通常用于执行未经测试或不受信任的程序或代码,它会 为待执行的程序创建一个独立的执行环境,内部程序的执行不会影响到外部程序的运行,下文我们来介绍一个“浏览器世界”的沙箱 前言：</p><p>说到沙箱，我们的脑海中可能会条件反射地联想到上面这个画面并瞬间变得兴致满满，不过很可惜本文并不涉及“我的世界”（老封面党了），下文将逐步介绍“浏览器世界”的沙箱。</p><p>1、什么是沙箱 在计算机安全中， 沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制 ，通常用于执行未经测试或不受信任的程序或代码，它会 为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行 。</p><p>例如，下列场景就涉及了沙箱这一抽象的概念：</p><p>我们开发的页面程序运行在浏览器中，程序只能修改浏览器允许我们修改的那部分接口，我们无法通过这段脚本影响到浏览器之外的状态，在这个场景下浏览器本身就是一个沙箱。 浏览器中每个标签页运行一个独立的网页，每个标签页之间互不影响，这个标签页就是一个沙箱。 ...... 2、沙箱有什么应用场景 上述介绍了一些较为宏观的沙箱场景，其实在日常的开发中也存在很多的场景需要应用这样一个机制：</p><p>执行 JSONP 请求回来的字符串时或引入不知名第三方 JS 库时，可能需要创造一个沙箱来执行这些代码。 Vue 模板表达式的计算是运行在一个沙盒之中的，在模板字符串中的表达式只能获取部分全局对象，这一点官方文档有提到，这一点官方文档有提到，详情可参阅源码</p><p>在线代码编辑器，如 CodeSanbox 等在线代码编辑器在执行脚本时都会将程序放置在一个沙箱中，防止程序访问/影响主页面。 许多应用程序提供了插件（Plugin）机制，开发者可以书写自己的插件程序实现某些自定义功能。开发过插件的同学应该知道开发插件时会有很多限制条件，这些应用程序在运行插件时需要遵循宿主程序制定的运行规则，插件的运行环境和规则就是一个沙箱。例如下图是 Figma 插件的运行机制：</p><p>总而言之，只要遇到不可信的第三方代码，我们就可以使用沙箱将代码进行隔离，从而保障外部程序的稳定运行。如果不做任何处理地执行不可信代码，在前端中最直观的副作用/危害就是污染、篡改全局 window 状态，影响主页面功能甚至被 XSS 攻击。 // 子应用代码</p><p>window.location.href = &#39;www.diaoyu.com&#39;</p><p>Object.prototype.toString = () =&gt; {</p><pre><code>console.log(&#39;You are a fool :)&#39;)
</code></pre><p>}</p><p>document.querySelectorAll(&#39;div&#39;).forEach(node =&gt; node.classList.add(&#39;hhh&#39;))</p><p>sendRequest(document.cookie)</p><p>... 3、如何实现一个 JS 沙箱 要实现一个沙箱，其实就是去制定一套程序执行机制，在这套机制的作用下 沙箱内部程序的运行不会影响到外部程序的运行 。</p><p>3.1 最简陋的沙箱 要实现这样一个效果，最直接的想法就是程序中访问的 所有变量均来自可靠或自主实现的上下文环境而不会从全局的执行环境中取值， 那么要实现变量的访问均来自一个可靠上下文环境，</p><p>我们需要为待执行程序构造一个作用域：</p><p>// 执行上下文对象 const ctx = func: variable =&gt; { console.log(variable) }, foo: &#39;foo&#39; }</p><p>// 最简陋的沙箱 function poorestSandbox(code, ctx) { eval(code) // 为执行程序构造了一个函数作用域 }</p><p>// 待执行程序 const code = <code> ctx.foo = &#39;bar&#39; ctx.func(ctx.foo)</code></p><p>poorestSandbox(code, ctx) // bar 这样的一个沙箱要求源程序在获取任意变量时都要加上执行上下文对象的前缀，这显然是非常不合理的，因为我们没有办法控制第三方的行为，是否有办法去掉这个前缀呢？</p><p>3.2 非常简陋的沙箱（With） 使用 with声明可以帮我们去掉这个前缀， with 会在作用域链的顶端添加一个新的作用域，该作用域的变量对象会加入 with 传入的对象，因此相较于外部环境其内部的代码在查找变量时会优先在该对象上进行查找。</p><p>// 执行上下文对象 const ctx = { func: variable =&gt; { console.log(variable) }, foo: &#39;foo&#39; }</p><p>// 非常简陋的沙箱 function veryPoorSandbox(code, ctx) { with(ctx) { // Add with eval(code) } }</p><p>// 待执行程序 const code = <code> foo = &#39;bar&#39; func(foo)</code></p><p>veryPoorSandbox(code, ctx) // bar 这样一来就 实现了执行程序中的变量在沙箱提供的上下文环境中查找先于外部执行环境 的效果。</p><p>问题来了，在提供的上下文对象中没有找到某个变量时，代码仍会沿着作用域链一层一层向上查找，这样的一个沙箱仍然无法控制内部代码的执行。我们 希望沙箱中的代码只在手动提供的上下文对象中查找变量，如果上下文对象中不存在该变量则直接报错或返回 undefined 。</p><p>3.3 没那么简陋的沙箱（With + Proxy） 为了解决上述抛出的问题，我们借助 ES2015 的一个新特性—— Proxy ， Proxy 可以代理一个对象，从而拦截并定义对象的基本操作。</p><p>Proxy 中的 get 和 set 方法只能拦截已存在于代理对象中的属性，对于代理对象中不存在的属性这两个钩子是无感知的。因此这里我们使用 Proxy.has() 来拦截 with 代码块中的任意变量的访问，并设置一个白名单，在白名单内的变量可以正常走作用域链的访问方式，不在白名单内的变量会继续判断是否存在沙箱自行维护的上下文对象中，存在则正常访问，不存在则直接报错。</p><p>由于 has 会拦截 with 代码块中所有的变量访问，而我们只是想监控被执行代码块中的程序，因此还需要转换一下手动执行代码的形式 ：</p><p>// 构造一个 with 来包裹需要执行的代码，返回 with 代码块的一个函数实例 function withedYourCode(code) { code = &#39;with(globalObj) {&#39; + code + &#39;}&#39; return new Function(&#39;globalObj&#39;, code) }</p><p>// 可访问全局作用域的白名单列表 const access_white_list = [&#39;Math&#39;, &#39;Date&#39;]</p><p>// 待执行程序 const code = <code> Math.random() location.href = &#39;xxx&#39; func(foo)</code></p><p>// 执行上下文对象 const ctx = { func: variable =&gt; { console.log(variable) }, foo: &#39;foo&#39; }</p><p>// 执行上下文对象的代理对象 const ctxProxy = new Proxy(ctx, { has: (target, prop) =&gt; { // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) { // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop) }</p><pre><code>  if (!target.hasOwnProperty(prop)) {
      throw new Error(\`Invalid expression - \${prop}! You can not do that!\`)
  }

  return true
}
</code></pre><p>})</p><p>// 没那么简陋的沙箱</p><p>function littlePoorSandbox(code, ctx) {</p><pre><code>withedYourCode(code).call(ctx, ctx) // 将 this 指向手动构造的全局代理对象
</code></pre><p>}</p><p>littlePoorSandbox(code, ctxProxy)</p><p>// Uncaught Error: Invalid expression - location! You can not do that! 到这一步，其实很多较为简单的场景就可以覆盖了（eg: Vue 的模板字符串），那如果想要实现 CodeSanbox这样的 web 编辑器呢？在这样的编辑器中我们可以任意使用诸如 document 、 location 等全局变量且不会影响主页面。</p><p>从而又衍生出另一个问题——如何让子程序使用所有全局对象的同时不影响外部的全局状态呢？</p><p>3.4 天然的优质沙箱（iframe） 听到上面这个问题 iframe 直呼内行， iframe 标签可以创造一个独立的浏览器原生级别的运行环境，这个环境由浏览器实现了与主环境的隔离。在 iframe 中运行的脚本程序访问到的全局对象均是当前 iframe 执行上下文提供的，不会影响其父页面的主体功能，因此 使用 iframe 来实现一个沙箱是目前最方便、简单、安全的方法 。</p><p>试想一个这样的场景：一个页面中有多个沙箱窗口，其中有一个沙箱需要与主页面共享几个全局状态（eg: 点击浏览器回退按钮时子应用也会跟随着回到上一级），另一个沙箱需要与主页面共享另外一些全局状态（eg: 共享 cookie 登录态）。</p><p>虽然浏览器为主页面和 iframe 之间提供了 postMessage 等方式进行通信，但单单使用 iframe 来实现这个场景是比较困难且不易维护的。</p><p>3.5应该能用的沙箱（With + Proxy + iframe） 为了实现上述场景，我们把上述方法缝合一下即可：</p><p>利用 iframe 对全局对象的天然隔离性，将 iframe.contentWindow 取出作为当前沙箱执行的全局对象 将上述沙箱全局对象作为 with 的参数限制内部执行程序的访问，同时使用 Proxy 监听程序内部的访问。 维护一个共享状态列表，列出需要与外部共享的全局状态，在 Proxy 内部实现访问控制。</p><p>// 沙箱全局代理对象类 class SandboxGlobalProxy {</p><pre><code>constructor(sharedState) {
    // 创建一个 iframe 对象，取出其中的原生浏览器全局对象作为沙箱的全局对象
    const iframe = document.createElement(&#39;iframe&#39;, {url: &#39;about:blank&#39;})
    document.body.appendChild(iframe)
    const sandboxGlobal = iframe.contentWindow // 沙箱运行时的全局对象
 

    return new Proxy(sandboxGlobal, {
        has: (target, prop) =&gt; { // has 可以拦截 with 代码块中任意属性的访问
            if (sharedState.includes(prop)) { // 如果属性存在于共享的全局状态中，则让其沿着原型链在外层查找
                return false
            }

            if (!target.hasOwnProperty(prop)) {
                throw new Error(\`Invalid expression - \${prop}! You can not do that!\`)
            }
            return true
        }
    })

}
</code></pre><p>}</p><p>function maybeAvailableSandbox(code, ctx) {</p><pre><code>withedYourCode(code).call(ctx, ctx)
</code></pre><p>}</p><p>const code_1 = \`</p><pre><code>console.log(history == window.history) // false

window.abc = &#39;sandbox&#39;

Object.prototype.toString = () =&gt; {

    console.log(&#39;Traped!&#39;)

}

console.log(window.abc) // sandbox
</code></pre><p>\`</p><p>const sharedGlobal_1 = [&#39;history&#39;] // 希望与外部执行环境共享的全局对象</p><p>const globalProxy_1 = new SandboxGlobalProxy(sharedGlobal_1)</p><p>maybeAvailableSandbox(code_1, globalProxy_1)</p><p>window.abc // undefined</p><p>Object.prototype.toString() // [object Object] 并没有打印 Traped 从实例代码的结果可以看到借用 iframe 天然的环境隔离优势和 with + Proxy 强大的控制力，我们实现了沙箱内全局对象和外层的全局对象的隔离，并实现了共享部分全局属性。</p><p>3.6 沙箱逃逸（Sandbox Escape） 沙箱于作者而言是一种安全策略，但于使用者而言可能是一种束缚。脑洞大开的开发者们尝试用各种方式摆脱这种束缚，也称之为 沙箱逃逸 。因此一个沙箱程序最大的挑战就是如何检测并禁止这些预期之外的程序执行。</p><p>上面实现的沙箱似乎已经满足了我们的功能，大功告成了吗？其实不然，下列操作均会对沙箱之外的环境造成影响，实现沙箱逃逸：</p><p>访问沙箱执行上下文中某个对象内部属性时， Proxy 无法捕获到这个属性的访问操作 。例如我们可以直接在沙箱的执行上下文中通过 window.parent 拿到外层的全局对象。</p><p>// 访问沙箱对象中对象的属性时，省略了上文中的部分代码</p><p>const ctx = {</p><pre><code>window: {

    parent: {...},

    ...

}
</code></pre><p>}</p><p>const code = \`</p><pre><code>window.parent.abc = &#39;xxx&#39;
</code></pre><p>\`</p><p>window.abc // xxx 通过访问原型链实现逃逸，JS 可以直接声明一个字面量，沿着该字面量的原型链向上查找原型对象即可访问到外层的全局对象，这种行为亦是无法感知的。</p><p>const code = \`</p><pre><code>({}).constructor.prototype.toString = () =&gt; {

    console.log(&#39;Escape!&#39;)

}
</code></pre><p>\`</p><p>({}).toString() // Escape! 预期是 [object Object] 3.7 “无瑕疵”的沙箱（Customize Interpreter） 通过上述的种种方式来实现一个沙箱或多或少存在一些缺陷，那是否存在一个趋于完备的沙箱呢？</p><p>其实有不少开源库已经在做这样一件事情，也就是分析源程序结构从而手动控制每一条语句的执行逻辑，通过这样一种方式无论是指定程序运行时的上下文环境还是捕获妄想逃脱沙箱控制的操作都是在掌控范围内的。实现这样一个沙箱本质上就是实现一个自定义的解释器。</p><p>function almostPerfectSandbox(code, ctx, illegalOperations) {</p><pre><code>return myInterpreter(code, ctx, illegalOperations) // 自定义解释器
</code></pre><p>} 4、总结 本文主要介绍了沙箱的基本概念、应用场景以及引导各位思考如何去实现一个 JavaScript 沙箱。沙箱的实现方式并不是一成不变的，应当结合具体的场景分析其需要达成的目标。除此之外，沙箱逃逸的防范同样是一件任重而道远的事，因为很难在构建的初期就覆盖所有的执行 case。</p><p>没有一个沙箱的组装是一蹴而就的，就像“我的世界”一样。</p><p>5、参考 参考资料： 源码: https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js CodeSanbox: https://codesandbox.io/ with: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with Proxy: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy CodeSanbox: https://codesandbox.io/ Writing a JavaScript framework - Sandboxed Code Evaluation: https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/ 说说 JS 中的沙箱: https://juejin.cn/post/6844903954074058760#heading-1</p><p><a href="https://www.jb51.net/article/226694.htm" target="_blank" rel="noopener noreferrer">js沙箱</a><a href="https://www.zhihu.com/question/364970876" target="_blank" rel="noopener noreferrer">ES6 的 Symbol 为什么还有 Symbol.unscopables 这个内置方法？</a><a href="https://juejin.cn/post/6844903977759293448" target="_blank" rel="noopener noreferrer">动手实现一个 JavaScript 沙箱</a><a href="https://zhuanlan.zhihu.com/p/589341143?utm_id=0" target="_blank" rel="noopener noreferrer">30 行代码实现 JS 沙箱</a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8_eval%EF%BC%81" target="_blank" rel="noopener noreferrer">永远不要使用_eval！</a></p><p>沙箱 含义：</p><p>沙盒（英语：sandbox，又译为沙箱）是一种安全机制，为执行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。 JS 沙箱就是一个能让 JS 代码独立运行的一个环境。在 Chrome 一个标签页就是一个 JS 沙箱。</p><p>应用：</p><p>在线代码编辑器。https://codesandbox.io/ 微前端隔离项目代码，使其不相互影响。 实现 JS 沙箱 在 JavaScript 中，不同作用域可以通过作用域链进行访问（如闭包），而且通过这种方式，所有作用域都能访问到全局对象。</p><p>要实现沙箱的隔离效果，需要把代码运行在一个独立的作用域，限制它对其他作用域以及全局对象的访问。</p><p>例子如下，在沙箱内变量赋值不会影响沙箱外的对象，这是 createSandbox 函数需要实现的基本功能。</p><p>window.aaa = 10; const sandbox = createSandbox(window); sandbox(<code> aaa = 0; bbb = 0; console.log(aaa, bbb); // 0 0</code>) console.log(window.aaa, window.bbb); // 10 undefined 一、代码执行 在 JavaScript 中，动态执行代码的方法有 Function 和 eval 。</p><p>const aaa = 10; function fn(){ let aaa = 0; eval(&#39;console.log(&quot;aaa:&quot;, aaa)&#39;) // aaa:0 Function(&#39;str&#39;, &#39;consoel.log(str, aaa)&#39;)(&#39;aaa:&#39;) // aaa:10 } fn() 二者对比:</p><p>eval 则是在当前作用域直接执行代码，代码可以直接访问当前作用域。而 Function 创建的函数只会在全局作用域中运行（除主动修改作用域：bind，call 等），所以 Function 相对安全。 因为使用 Function 相当于定义一个函数，会进行分词和解析等编译工作，如果 Funcion 中执行的内容有语法错误，还是会报错 Uncaught SyntaxError 语法错误。但 eval 是直接对执行代码进行机器码的转译，缺少引擎编译带来的性能优化。所以 Function 比 eval 性能更优。</p><p>代码中永远不要使用 eval</p><p>选择 Function 函数来动态执行代码后，我们可以得出以下实现：</p><p>const createSandbox = () =&gt; code =&gt; Function(code)() 二、作用域固定 虽然使用 Function 可以让沙箱代码固定在全局作用域中执行，但我们还是需要限制代码访问全局对象。</p><p>我们可以使用 Object.create() 来创建一个全局对象的副本，然后使用 with 让沙箱代码访问这个副本对象，从而达到隔离的效果。</p><p>with 语句可以将某个对象添加到作用域链的顶部。 // 实现代码 const createSandbox = global =&gt; { const context = Object.create(global) return code =&gt; Function(<code>proxy</code>, <code>with(proxy){\${code}}</code>)(context); };</p><p>// 测试代码 window.aaa = 10; const sandbox = createSandbox(window); sandbox(<code> aaa = 20; console.log(aaa); // 20</code>) console.log(aaa); // 10 三、全局对象代理 使用 with 的方式还存在一个问题，就是当访问全局对象不存在的字段时，还是能够访问到全局对象，比如新增字段。</p><p>使用 Proxy 代理 with 对象中的 has 方法，让每次判断都返回 true，这样就能真正阻断代码通过作用域链访问全局对象。</p><p>with 语句是通过 in 运算符来判定访问的字段是否在对象中，从而决定是否继续通过作用域链往上找。 // 实现代码 const createSandbox = global =&gt; { const context = Object.create(global); const proxy = new Proxy(context, {has: () =&gt; true}); return code =&gt; Function(<code>proxy</code>, <code>with(proxy){\${code}}</code>)(context); }; // 测试代码 window.aaa = 10; const sandbox = createSandbox(window); sandbox(<code> aaa = 0; bbb = 0; console.log(aaa, bbb); // 0 0</code>) console.log(aaa, bbb); // 10 undefined 四、特殊处理 上述代码虽然实现了基本的沙箱功能，但显然还存在一些问题：</p><p>在浏览器中，全局对象 window 中字段 globalThis，window，parent 和 self 都是指向 window，需要进行重写。 Object.create(global) 生成的对象能通过原型链 <strong>proto</strong> 访问到全局对象。需要改用空对象，然后在 proxy 中代理 get 方法，返回 global 的字段访问。 避免沙箱代码中使用 this 访问全局对象，使用 bind 方法修改作用域。 // 处理上述问题后代码 const createSandbox = global =&gt; { const context = Object.create(null); const proxy = new Proxy(context, { has: () =&gt; true, get: (target, prop) =&gt; { switch(prop) { case &#39;globalThis&#39;: case &#39;window&#39;: case &#39;parent&#39;: case &#39;self&#39;: return proxy; default: return (prop in target) ? target[prop] : global[prop]</p><pre><code>        }
    } 
});

return code =&gt; Function(\`proxy\`, \`with(proxy){\${code}}\`).bind(proxy)(proxy);
</code></pre><p>}; 浏览器还会对一些内置函数进行保护，比如 alert 和 setTimeout 等，这些函数必须运行在 window 作用域下。需要把函数的作用域修改回 window。</p><p>这些函数都有个特点就是都是非构造函数，不能 new，没有 prototype 属性，我们可以用这个特点来进行过滤。</p><p>// 基于上述代码增加判断 default: if (prop in target) { return target[prop]; } const value = global[prop]; if (typeof value === &#39;function&#39; &amp;&amp; !value.prototype){ return value.bind(global); } return value; 五、最终代码 最终 createSandbox 函数的实现如下：</p><p>const createSandbox = global =&gt; { const context = Object.create(null); const proxy = new Proxy(context, { has: () =&gt; true, get: (target, prop) =&gt; { switch(prop) { case &#39;globalThis&#39;: case &#39;window&#39;: case &#39;parent&#39;: case &#39;self&#39;: return proxy; default: if (prop in target) { return target[prop]; } const value = global[prop]; if (typeof value === &#39;function&#39; &amp;&amp; !value.prototype){ return value.bind(global); } return value; } } });</p><pre><code>return code =&gt; Function(\`proxy\`, \`with(proxy){\${code}}\`).bind(proxy)(proxy);
</code></pre><p>}; 六、使用效果 可以在同一页面中同时运行 vue2 和 vue3 的代码，互不冲突。</p><p>demo： https://codesandbox.io/s/clever-sky-ycq3j?file=/index.html</p><p>其他 存在问题（暂时无解） 在沙箱中使用 Function(&#39;return this&#39;)() 还是能实现沙箱逃逸。虽然可以在代理中重写 Function，把生成的函数使用 bind(proxy) 修改作用域再返回，但这样会导致所有用 Function 生成的函数的作用域提前固定了，即使之后再调用 call， 也无法改变作用域，导致调用报错。 拿到全局属性的引用后可以篡改属性对象中的值。 冷知识 Symbol.unscopables // 例子一 function fn1(props){ with(props){ console.log(props.length); } } fn1([]) // 0</p><p>// 例子二 function fn2(props){ with(props){ console.log(props.length); } } Array.prototype.props = {length: 10}; fn2([]) // 10 这两个例子主要的变化是在原型链上增加了一个属性，导致 with 语句可以成功从对象中查找到字段，实际输出的是 props.props.length，导致输出和预期变得不一样。</p><p>可以想想 ES6 对数组原型新增了多少方法，每个方法都可能导致这个问题。虽然这个代码看起来写法比较有歧义，但确实出现在了当时比较流行的框架 EXT 中。为了兼容这种情况，TC39 加了一条规则。</p><p>Symbol.unscopables 的引入，唯一作用就是解决 with 执行环境下的历史问题。TC39 把 ES6 以后新加数组原型链方法全部加到 Array.prototype[Symbol.unscopables] 中，包括 includes、keys 和 values 等等。</p><p>function fn(keys){ with(keys){ console.log(keys.length); } } Array.prototype.keys = {length: 10} fn([]) // 0 参考 MDN Web Docs 动手实现一个 JavaScript 沙箱 ES6 的 Symbol 为什么还有 Symbol.unscopables 这个内置方法</p>`,119)]))}const l=e(p,[["render",r],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/article/1quh4r54/","title":"沙箱","lang":"zh-CN","frontmatter":{"title":"沙箱","createTime":"2025/01/21 15:37:41","permalink":"/article/1quh4r54/","watermark":true},"headers":[],"readingTime":{"minutes":18.62,"words":5585},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/front/沙箱.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"67ca11","sort":10006,"name":"front"}],"bulletin":false}');export{l as comp,d as data};
