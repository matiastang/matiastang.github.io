import{_ as p,c as l,a as s,b as t,d as r,e as a,f as n,r as d,o as u}from"./app-CS9K37Kg.js";const i={};function b(c,e){const o=d("RouteLink");return u(),l("div",null,[e[21]||(e[21]=s('<p>浏览器中使用 <code>JavaScript</code> 请求接口的原生方式，主要有两种方式：<code>XMLHttpRequest</code> 和 <code>fetch</code>。</p><p>除了上面两种常规的方式，还有其他一些方式，如：<code>EventSource</code>、<code>WebSocket</code>。</p><h2 id="xmlhttprequest" tabindex="-1"><a class="header-anchor" href="#xmlhttprequest"><span>XMLHttpRequest</span></a></h2><p>XMLHttpRequest（XHR）是 <code>JavaScript</code> 中用于与服务器交换数据的 API。它允许你通过 <code>JavaScript</code> 发送 HTTP 请求，并处理响应。<code>XMLHttpRequest</code> 是一种非常灵活和强大的方式来与服务器进行通信，但它也有一些缺点，例如它是基于事件回调的，不支持 Promise，并且需要手动处理错误和超时。</p><p>XMLHttpRequest API 使网站能够使用来自服务器的数据仅更新页面的一部分，而不必导航到一个全新的页面。这种做法有时也称为 <a href="https://developer.mozilla.org/en-US/docs/Glossary/AJAX" target="_blank" rel="noopener noreferrer">AJAX</a></p><p>一些三方库，如：<code>jQuery.ajax()</code>、<code>axios</code>，都是基于 <code>XMLHttpRequest</code> 的封装。</p>',6)),t("p",null,[e[1]||(e[1]=t("code",null,"XMLHttpRequest",-1)),e[2]||(e[2]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/wunz2df4.html"},{default:n(()=>e[0]||(e[0]=[r("XMLHttpRequest 使用")])),_:1})]),e[22]||(e[22]=s('<h2 id="fetch" tabindex="-1"><a class="header-anchor" href="#fetch"><span>Fetch</span></a></h2><p>Fetch API 是 XMLHttpRequest API 的更灵活、更强大的替代品。Fetch API 使用 Promise 而不是事件来处理异步响应，与 Service Worker 很好地集成，并支持 HTTP 的高级方面，例如 CORS。由于这些原因，现代 Web 应用程序中通常使用 Fetch API 而不是 XMLHttpRequest。</p><p><code>fetch</code> 是 <code>ES2015</code> 引入的新特性。从<a href="https://caniuse.com" target="_blank" rel="noopener noreferrer">caniuse</a>查询结果中看， <code>IE</code>中只支持<code>XMLHttpRequest</code>，不支持<code>fetch</code>，其他基本都一样了。</p>',3)),t("p",null,[e[4]||(e[4]=t("code",null,"fetch",-1)),e[5]||(e[5]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/2rw9s4ov.html"},{default:n(()=>e[3]||(e[3]=[r("fetch 使用")])),_:1})]),e[23]||(e[23]=t("h2",{id:"eventsource",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#eventsource"},[t("span",null,"EventSource")])],-1)),e[24]||(e[24]=t("p",null,"EventSource 接口是 web 内容与服务器发送事件通信的接口。一个 EventSource 实例会和 HTTP 服务器开启一个持久化的连接，以 text/event-stream 格式发送事件，此连接会一直保持开启直到通过调用 EventSource.close() 关闭。",-1)),t("p",null,[e[7]||(e[7]=t("code",null,"EventSource",-1)),e[8]||(e[8]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/jvhedlr5.html"},{default:n(()=>e[6]||(e[6]=[r("EventSource 使用")])),_:1})]),e[25]||(e[25]=s('<h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket"><span>WebSocket</span></a></h2><p><code>WebSocket</code> 是一种全双工通信协议，允许客户端和服务器之间进行实时的双向通信，并且支持<code>POST</code>请求。但是值得注意的是<code>WebSocket</code>只支持<code>ws</code>或<code>wss</code>开头的接口。<code>WebSocket</code> 握手时并没有提供直接设置请求头的标准方法，它的握手阶段是由浏览器自动处理的，因此你不能直接在创建 <code>WebSocket</code> 连接时设置请求头，但可以通过通过 <code>URL</code> 参数传递的方式传递信息。</p>',2)),t("p",null,[e[10]||(e[10]=t("code",null,"WebSocket",-1)),e[11]||(e[11]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/x19bqs0v.html"},{default:n(()=>e[9]||(e[9]=[r("WebSocket 使用")])),_:1})]),e[26]||(e[26]=t("h2",{id:"webtransport",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#webtransport"},[t("span",null,"WebTransport")])],-1)),e[27]||(e[27]=t("p",null,"WebTransport API 提供了对 WebSockets 的现代更新，使用 HTTP/3 传输在客户端和服务器之间传输数据。WebTransport 支持多个流、单向流和无序传输。它支持通过流进行可靠传输，并通过类似 UDP 的数据报实现不可靠的传输。",-1)),t("p",null,[e[13]||(e[13]=t("code",null,"WebTransport",-1)),e[14]||(e[14]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/nobwyjxs.html"},{default:n(()=>e[12]||(e[12]=[r("WebTransport 使用")])),_:1})]),e[28]||(e[28]=t("h2",{id:"三方库",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#三方库"},[t("span",null,"三方库")])],-1)),e[29]||(e[29]=t("h3",{id:"jquery-ajax",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#jquery-ajax"},[t("span",null,"jQuery.ajax()")])],-1)),e[30]||(e[30]=t("p",null,[r("jQuery 的 "),t("code",null,"ajax()"),r(" 方法是一个用于发送 HTTP 请求的函数。它接受一个配置对象作为参数，该对象可以包含请求的类型、URL、数据、回调函数等信息。"),t("code",null,"ajax()"),r(" 方法返回一个 "),t("code",null,"jqXHR"),r(" 对象，该对象表示一个异步请求。")],-1)),t("p",null,[e[16]||(e[16]=t("code",null,"jQuery.ajax()",-1)),e[17]||(e[17]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/uk6m8qek.html"},{default:n(()=>e[15]||(e[15]=[r("jQuery 请求接口")])),_:1})]),e[31]||(e[31]=t("h3",{id:"axios",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#axios"},[t("span",null,"axios")])],-1)),e[32]||(e[32]=t("p",null,"Axios 是一个基于 Promise 的 HTTP 客户端，适用于 node.js 和浏览器。它是同构的（ 它可以在具有相同代码库的浏览器和 nodejs 中运行）。在服务器端，它使用本机 node.js http 模块，而在客户端（浏览器）上使用 XMLHttpRequest。",-1)),t("p",null,[e[19]||(e[19]=t("code",null,"Axios",-1)),e[20]||(e[20]=r(" 的具体使用，参考")),a(o,{to:"/javascript/request/aa3k4mol.html"},{default:n(()=>e[18]||(e[18]=[r("Axios 使用")])),_:1})]),e[33]||(e[33]=s('<h3 id="socket-io" tabindex="-1"><a class="header-anchor" href="#socket-io"><span>Socket.IO</span></a></h3><p><a href="https://socket.io" target="_blank" rel="noopener noreferrer">Socket.IO</a> 是一个库，可在客户端和服务器之间实现低延迟、双向和基于事件的通信。Socket.IO 不是 WebSocket 实现。而是多种技术的综合实现，所以尽管 Socket.IO 确实在可能的情况下使用 WebSocket 进行传输，但它会向每个数据包添加额外的元数据。这就是为什么 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，并且 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。正因为底层使用了多种技术，所以具有降级功能，即如果 WebSocket 连接失败，它将尝试使用其他方法（如轮询），这使得在可靠性更新方面，Socket.IO 比 WebSocket 更好。</p><p><code>Socket.IO</code> 的具体使用，参考官方文档<a href="https://socket.io" target="_blank" rel="noopener noreferrer">Socket.IO</a></p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://caniuse.com" target="_blank" rel="noopener noreferrer">兼容性查询</a></p><p><a href="https://socket.io" target="_blank" rel="noopener noreferrer">Socket.IO</a></p><p><a href="https://web.nodejs.cn/en-us/docs/web/api/webtransport_api" target="_blank" rel="noopener noreferrer">MDN WebTransport</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener noreferrer">MDN WebSocket</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" target="_blank" rel="noopener noreferrer">MDN EventSource</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener noreferrer">MDN Fetch API</a></p><p><a href="https://jquery.com" target="_blank" rel="noopener noreferrer">jQuery</a></p><p><a href="https://axios-http.com/docs/intro" target="_blank" rel="noopener noreferrer">axios 文档</a></p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">Github axios</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API" target="_blank" rel="noopener noreferrer">MDN XMLHttpRequest API</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/AJAX" target="_blank" rel="noopener noreferrer">MDN AJAX</a></p>',15))])}const k=p(i,[["render",b],["__file","2jr1jedy.html.vue"]]),m=JSON.parse('{"path":"/javascript/request/2jr1jedy.html","title":"JavaScript 请求接口的方式","lang":"zh-CN","frontmatter":{"title":"JavaScript 请求接口的方式","createTime":"2025/01/23 17:11:05","permalink":"/javascript/request/2jr1jedy.html","watermark":true},"headers":[],"readingTime":{"minutes":3.84,"words":1153},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/javascript/request/JavaScript请求接口的方式.md","bulletin":false}');export{k as comp,m as data};
