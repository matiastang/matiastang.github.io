import{_ as t,c as a,a as o,o as s}from"./app-CS9K37Kg.js";const n={};function c(r,e){return s(),a("div",null,e[0]||(e[0]=[o('<h1 id="oauth2" tabindex="-1"><a class="header-anchor" href="#oauth2"><span>OAuth2</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>OAuth2，全名是Open Authorization 2.0，是一个行业标准的授权框架。它允许用户提供一个令牌给第三方应用，而不是直接暴露用户的登录信息，从而安全地授权第三方应用访问用户在某一服务上的信息</p><h2 id="oauth2的四种授权模式" tabindex="-1"><a class="header-anchor" href="#oauth2的四种授权模式"><span>OAuth2的四种授权模式</span></a></h2><p>OAuth2定义了四种授权模式，每种模式适用于不同的场景：</p><ul><li>授权码模式（Authorization Code）：这是最常用的模式，适用于有服务器的Web应用。它通过用户代理重定向来获得授权码，然后交换令牌。</li><li>隐式模式（Implicit）：适用于没有后端服务器的纯前端应用，如单页应用（SPA）。它直接在客户端获得令牌，而不是授权码。</li><li>密码模式（Resource Owner Password Credentials）：在用户信任客户端的情况下使用，如用户的设备上的应用。用户直接提供用户名和密码给客户端，客户端使用这些信息获得令牌。</li><li>客户端凭证模式（Client Credentials）：适用于客户端访问自己保护的资源，不涉及用户，通过客户端的凭证直接获取令牌。</li></ul><h2 id="_2-oauth-roles" tabindex="-1"><a class="header-anchor" href="#_2-oauth-roles"><span>2.OAuth Roles</span></a></h2><p>OAuth 定义了四种角色</p><ul><li>资源拥有者 (Resource Owner)</li><li>客户端 (Client)</li><li>资源服务器 (Resource Server)</li><li>授权服务器 (Authorization Server) 资源拥有者其实就是真实的用户，用户授权给第三方应用访问在其他系统的用户信息。第三方应用访问授权用户的信息范围 scope 属于申请接入服务时选择的权限之内(例如：读或写访问权限)</li></ul><p>资源服务控制用户的信息，授权服务验证用户提供的信息是否正确并返回 access token 给第三方应用。 站在第三方开发者的角度看，被接入的系统提供的服务 API 同时实现了资源和授权角色。在这里把资源服务端和授权服务端统一为“服务角色或 API 角色”。</p><p>客户端就是要求接入的第三方应用，获取用户在提供服务的系统的账户信息。对于客户端而言，最终获取到用户在服务端的账户信息首先需要用户授权，用户授权后传给提供服务端验证成功之后返回 access token ，在通过 access token 请求提供服务的系统（在这里我们成为 API ，下文也是）获取用户在 API 中的账户信息。</p><h2 id="授权码-grant-type-authorization-code" tabindex="-1"><a class="header-anchor" href="#授权码-grant-type-authorization-code"><span>授权码 (Grant Type: Authorization Code)</span></a></h2><p>授权码是 OAuth2 授权最广泛的方式，得益于平台给第三方应用分配的 ID 和密码都是隐藏在第三方应用的后端代码中。因为授权码是基于重定向的方式，要想使用授权码的方式，第三方应用必须能够调用用户系统中的应用（譬如浏览器）、和提供一个接口接收平台服务的回调获取授权码。</p><p>一步步解释授权码的流程图</p><p>步骤一：构建获取授权码请求链接 下文提到的例子都是基于 digiterocean 的 OAuth2 第一步是构建一个请求 Auth Server 获取授权码的链接，向服务端发起请求</p><p>https://cloud.digitalocean.com/v1/oauth/authorize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_URL&amp;scope=read 分解请求链接：</p><p>https://cloud.digitalocean.com/v1/oauth/authorize 表示服务端授权 endpoint client_id 平台分配给第三方应用的 ID redirect_uri=CALLBACK_URL 第三方开发者在平台新建第三方应用时填写的回调 URL response_type=code 指定服务端返回授权码 scope=read 指定第三方应用请求权限类型 步骤二：用户授权给第三方应用 当用户点击第一步构建的链接之后，在用户已经登录服务端之后才能点击确认授权（譬如想通过微信登录某个第三方网址，你必须首先已经登录微博）。这是平台会给用户提供一个页面给用户确认是否授权。</p><p>步骤三：服务端给客户端返回授权码 当用户点击同意授权之后，服务端发起一个请求重定向到第三方平台填写的回调链接，且请求链接中同时包含了服务端生成的授权码。</p><p>https://dropletbook.com/callback?code=AUTHORIZATION_CODE 步骤四：第三方应用请求服务端，获取 access token 客户端获取到服务端返回的授权码之后，接着使用授权码和平台分配的密码请求服务端获取服务端的 access token 。第三方应用后端代码拼接的 URL 格式形似：</p><p>https://cloud.digitalocean.com/v1/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;code=AUTHORIZATION_CODE&amp;redirect_uri=CALLBACK_URL 在这里需注意两个参数，其一是 client_secret 没有暴露出去，在第三方应用后端代码中拼接请求链接；另一是 redirect_uri ，这里不是在平台新建应用时填写的回调链接，而是第三方应用已经实现的另一个 action 处理服务端返回 access token 的请求。</p><p>步骤五：第三方应用接收 access token 如果第四部客户端发送的信息被服务端校验成功，服务端则返回 access token ，有一些平台同时也同时传递 refresh token 。返回的 json 信息形似：</p><p>{ &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;token_type&quot;:&quot;bearer&quot;, &quot;expires_in&quot;:2592000, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;scope&quot;:&quot;read&quot;, &quot;uid&quot;:100101, &quot;info&quot;: { &quot;name&quot;:&quot;Mark E. Mark&quot;, &quot;email&quot;:&quot;mark@thefunkybunch.com&quot; } } 至此，已经走完 oauth 2 授权码的方式所有流程。在 access_token 没有失效的前提下，可通过 access_token 可以访问平台服务端提供的资源。另外如果还提供了 refresh_token ，在 access_token 失效的情况下，可以通过 refresh_token 再次去获取有效的 access_token 。</p><h2 id="隐式-grant-type-implicit" tabindex="-1"><a class="header-anchor" href="#隐式-grant-type-implicit"><span>隐式 (Grant Type: Implicit)</span></a></h2><p>相比授权码的授权许可这种后端实现，隐式授权类型在应用于前端实现（移动客户端或者浏览器），其缺陷就是并不保证平台分配给第三方平台的密码凭证足够安全。隐式授权同样也是基于重定向的方式，但是 access_token 通过网页重定向返回给第三方平台而不是通过接口调用的方式 暴露了 access_token 在重定向链接中，这点和授权码不同。另外，也不支持服务端校验客户端第三方应用密码，只是依赖在平台新建应用是填写的回调链接。</p><p>隐式授权不支持 refresh_token</p><p>授权大概流程如下：用户请求授权，同意授权后服务端把 access_token 拼接到回调链接上通过浏览器重定向到客户端，然后客户端获取到 access_token 。</p><p>通过流程图可看出在第三步和授权码不同的是服务端重定向到网页而不是通过接口把 access_token 返回给客户端。</p><p>步骤一：构建隐式授权请求链接 与授权码的步骤一差不多一致，只是 response_type 字段的参数值为 token</p><p>步骤二：用户授权给第三方 与授权码授权的步骤二完全一致</p><p>步骤三：通过服务端重定向链接，User-agent (浏览器或者 APP) 获取 access_token 与授权码不同的是，用户点击授权之后服务端通过把 access_token 通过网页重定向到回调链接，客户端通过重定向链接才能获取到access_token ；而授权码获取 access_token是通过服务端通过 ajax 请求的形式直接访问第三方应用的后端接口，把 access_token传给第三方后端。</p><p>步骤三：前端根据重定向调整 前端浏览器重定向请求第三方平台的后端</p><p>步骤五：第三方应用后端通过脚本获取在重定向链接中的 access_token 第三方应用后端通过脚本获取在重定向链接上的 access_token</p><p>步骤六：User-Agent 执行第三方应用后端返回的脚本把 access_token 返回给第三方平台后端。</p><h2 id="用户密码凭证" tabindex="-1"><a class="header-anchor" href="#用户密码凭证"><span>用户密码凭证</span></a></h2><p>用户直接给第三方应用提供在提供服务端账号密码，获取服务端的 access_token。这种授权方式常用于一个企业不同服务之间的账号互联互通。 用户给第三方应用提供账号密码之后，客户端发送 POST 请求给服务端获取access_token</p><p>https://oauth.example.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID 如果服务端校验客户端（第三方应用）传过来的账户密码正确，则把 access_token返回给客户端，用户授权完成。</p><h2 id="客户端凭证" tabindex="-1"><a class="header-anchor" href="#客户端凭证"><span>客户端凭证</span></a></h2><p>这种授权方式常用于第三方应用想要更改自身在服务提供方注册的应用信息，比如更改应用描述或回调链接地址。</p><p>第三方应用通过发送服务端分配的 ID 和密码给后端校验，POST 的 URL 格式形似：</p><p>https://oauth.example.com/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</p><h2 id="access-token-和-refresh-token" tabindex="-1"><a class="header-anchor" href="#access-token-和-refresh-token"><span>Access Token 和 Refresh Token</span></a></h2><p>第三方应用从服务提供平台获取到有效的 access_token 之后，即可根据平台提供的接口访问服务端的资源。</p><p>curl -X POST -H &quot;Authorization: Bearer ACCESS_TOKEN&quot;&quot;https://api.digitalocean.com/v2/$OBJECT&quot; 如果服务提供平台支持 refresh_token ，那么第三方应用的 access_token 失效之后，可通过 refresh_token 再次获取有效的 access_token</p><p>例如 digitalocean 支持第三方应用通过 POST 请求再此获取有效的 access_token</p><p>https://cloud.digitalocean.com/v1/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;refresh_token=REFRESH_TOKEN</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://blog.csdn.net/weixin_74318097/article/details/135180029" target="_blank" rel="noopener noreferrer">OAuth2授权框架的四种授权方式详解</a></p>',47)]))}const i=t(n,[["render",c],["__file","index.html.vue"]]),h=JSON.parse('{"path":"/article/fws0l33a/","title":"OAuth2","lang":"zh-CN","frontmatter":{"title":"OAuth2","createTime":"2025/01/21 15:10:24","permalink":"/article/fws0l33a/","watermark":true},"headers":[],"readingTime":{"minutes":8.06,"words":2418},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/back/authentication/OAuth2.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"7b2314","sort":10019,"name":"back"},{"id":"24a6d3","sort":10060,"name":"authentication"}],"bulletin":false}');export{i as comp,h as data};
