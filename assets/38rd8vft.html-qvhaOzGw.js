import{_ as e,c as i,a,o as n}from"./app-CS9K37Kg.js";const d="/javascript/number-math.png",t="/javascript/number.png",l={};function c(p,s){return n(),i("div",null,s[0]||(s[0]=[a(`<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p><code>JavaScript</code>中<code>Number</code>数据的存储遵循 <a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer"><code>IEEE 754</code></a> 规范：</p><ul><li>先把<code>Number</code>转成二进制科学计数法表示。</li><li>然后用<code>64</code>位存储二进制科学计算法的相关参数。</li></ul><h2 id="ieee-754介绍" tabindex="-1"><a class="header-anchor" href="#ieee-754介绍"><span><code>IEEE_754</code>介绍</span></a></h2><p><code>IEEE</code>二进制浮点数算术标准<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer"><code>IEEE 754</code></a>是20世纪80年代以来最广泛使用的浮点数运算标准，为许多<code>CPU</code>与浮点运算器所采用。</p><p>这个标准定义了表示浮点数的格式（包括负零<code>-0</code>）与反常值（<code>denormal number</code>），一些特殊数值（（无穷（<code>Inf</code>）与非数值（<code>NaN</code>）），以及这些数值的“浮点数运算符”。它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。</p><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer"><code>IEEE 754</code></a>规定了四种表示浮点数值的方式：<code>单精确度（32位）</code>、<code>双精确度（64位）</code>、<code>延伸单精确度</code>（43比特以上，很少使用）与<code>延伸双精确度</code>（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。</p><p>大部分编程语言都提供了<code>IEEE</code>浮点数格式与算术，但有些将其列为非必需的。例如，<code>IEEE 754</code>问世之前就有的<code>C</code>语言，现在包括了<code>IEEE</code>算术，但不算作强制要求（<code>C</code>语言的<code>float</code>通常是指<code>单精确度</code>，而<code>double</code>是指<code>双精确度</code>）。</p><p>该标准规定了四种表示浮点数值的方式，优点是：<strong>可以归一化处理整数和小数</strong>。</p><p><code>javascript</code> 对 <code>number</code> 数值的表示方式则采用了其中的<code>双精确度（64位）</code>的表示方式，所以 <code>javascript</code> 中所有的数值都是 <code>number</code> 类型，因为它既可以表示浮点数值，也可以表示整数。</p><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识"><span>基础知识</span></a></h2><p>在介绍数字的<code>IEEE 754</code>存储之前，先介绍一下下面的几个基础知识：</p><ul><li><code>十进制转为二进制</code></li><li><code>二进制科学计数法</code></li><li><code>二进制转为十进制</code></li></ul><p>为什么要介绍上面的知识呢，因为数字在内存中存储的是数字的<code>二进制</code>的<code>科学计数法</code>。</p><h3 id="十进制转为二进制方法" tabindex="-1"><a class="header-anchor" href="#十进制转为二进制方法"><span>十进制转为二进制方法</span></a></h3><p>下面以 <code>173.8125</code> 举例如何将之转化为二进制小数。</p><ol><li>针对整数部分 <code>173</code>，采取除 <code>2</code> 取余，结果逆序排列就将得整数部分的二进制。</li></ol><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>173 / 2 = 86 ... 1</span></span>
<span class="line"><span>86 / 2 = 43 ... 0</span></span>
<span class="line"><span>43 / 2 = 21 ... 1   ↑</span></span>
<span class="line"><span>21 / 2 = 10 ... 1   | 逆序排列</span></span>
<span class="line"><span>10 / 2 = 5 ... 0    |</span></span>
<span class="line"><span>5 / 2 = 2 ... 1     |</span></span>
<span class="line"><span>2 / 2 = 1 ... 0</span></span>
<span class="line"><span>1 / 2 = 0 ... 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到整数部分的二进制为 <code>10101101</code>。</p><ol start="2"><li>针对小数部分 <code>0.8125</code>，采用乘 <code>2</code> 取整，结果顺序排列就得小数部分的二进制。</li></ol><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>0.8125 * 2 = 1.625  |</span></span>
<span class="line"><span>0.625 * 2 = 1.25    | 顺序排列</span></span>
<span class="line"><span>0.25 * 2 = 0.5      |</span></span>
<span class="line"><span>0.5 * 2 = 1         ↓</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>得到小数部分的二进制为 <code>1101</code></p><ol start="3"><li>将前面两部的结果相加，结果为 <code>10101101.1101</code>，这就是<code>173.8125</code>这个数的二进制表示。</li></ol><h3 id="二进制转为十进制方法" tabindex="-1"><a class="header-anchor" href="#二进制转为十进制方法"><span>二进制转为十进制方法</span></a></h3><p>下面以刚刚得到的二进制 <code>10101101.1101</code> 为例进行转换。</p><ol><li>针对整数部分 <code>10101101</code> 计算逻辑如下：</li></ol><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>// 10101101</span></span>
<span class="line"><span>// ← 从右往左</span></span>
<span class="line"><span>1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7</span></span>
<span class="line"><span>= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128</span></span>
<span class="line"><span>= 173</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>小数部分 <code>1101</code> 计算逻辑如下</li></ol><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>// 1101</span></span>
<span class="line"><span>// 从左往右 →</span></span>
<span class="line"><span>1 * 2^-1 + 1 * 2^-2 + 0 * 2^-3 + 1 * 2^-4</span></span>
<span class="line"><span>= 1/2 + 1/4 + 0 + 1/16</span></span>
<span class="line"><span>= 13/16</span></span>
<span class="line"><span>= 0.8125</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>最后将整数部分跟小数部分相加得到最终结果 <code>173.8125</code>，和我们刚刚得到的结果一样。</li></ol><h3 id="科学计数法" tabindex="-1"><a class="header-anchor" href="#科学计数法"><span>科学计数法</span></a></h3><p>十进制 <code>173.8125</code> 的科学计数法为 <code>1.738125 * 10^2</code></p><p>十进制 <code>173.8125</code> 对应的二进制 <code>10101101.1101</code>，进一步可以使用<code>二进制的科学计数法</code>来表示，对应的二进制科学计数法为 <code>1.01011011101 * 2^7</code>。跟十进制类似，将底数 <code>10</code> 换为了 <code>2</code>，<code>7</code> 则代表小数点往右多少位。</p><p><strong>重点</strong> <code>1.01011011101 * 2^7</code> 为二进制，将其转换为 <code>10</code> 进制的过程为，先将 <code>1.01011011101</code> 做为 <code>2</code> 进制转换为 <code>10</code> 进制，得到 <code>1.35791015625</code>，然后将其乘以 <code>2^7</code> （也就是 <code>1.35791015625 * 128</code>），最后得到的十进制为 <code>173.8125</code></p><p>“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储。我们也可以理解成，浮点数就是小数。在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中<code>64位双精度浮点数</code>编码。这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p><p>对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用二进制科学计数法，这样小数点位置就固定了。</p><h2 id="ieee-754-规范" tabindex="-1"><a class="header-anchor" href="#ieee-754-规范"><span><code>IEEE 754</code> 规范</span></a></h2><p>前面提到为了<strong>归一化处理整数和小数</strong>，我们使用二进制科学计数法来表示数。计算机存储的数据是二进制（<code>0</code>或<code>1</code>）表示，先把二进制转换为科学记数法，公式如下：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V = M * 2^E</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其中，<code>M</code>的值为<code>[1, 2)</code>的浮点数，且每一位都是<code>0</code>或<code>1</code>，<code>E</code>为小数点移动的位数（肯定为整数），即指数。</p><p>举个例子，如：<code>27.0</code>转化成二进制为<code>11011.0</code></p><p>科学计数法表示为：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>1.10110 * 2^4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如上<code>M=1.10110</code>，<code>E=4</code>。所以我们需要在内存中存储的数据为<code>1.10110</code>、<code>4</code>这两个数就能通过公式的到二进制表示，进而到十进制表示。 因为二进制科学计数法的尾数<code>M</code>的第一位固定的<code>1</code>，所以可以直接省去（这样可以节省一个<code>bit</code>，导致<code>M</code>最多可以表示<code>53</code>位），即最终<code>M=10110</code>。</p><p>上面是对于正数而言，如果要区分正负我们需要添加一个符号位来表示，需要占用一个<code>bit</code>，<code>0</code>表示正数，<code>1</code>表示负数。</p><p>综上所述，<code>IEEE 754</code>规范中存储二进制的科学计数法分为三个部分：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V = (-1)^S * M * 2^E</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这就是<code>IEEE 754</code>规范中存储浮点数的公式，其中<code>S</code>表示符号位，<code>M</code>表示尾数，<code>E</code>表示指数。</p><p>下面以<code>双精度（64位）</code>为例</p><ul><li>符号位<code>S</code>：第 <code>1</code> 位是正负数符号位（<code>sign</code>），0代表正数，1代表负数。</li><li>指数位<code>E</code>：中间的 <code>11</code> 位存储指数（<code>exponent</code>），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为<code>1023</code>。</li><li>尾数位<code>M</code>：最后的 <code>52</code> 位是尾数（<code>mantissa</code>），超出的部分自动进一舍零。</li></ul><p><img src="`+d+'" alt="Number数学计算公式"><img src="'+t+`" alt="Number内存示意图mat"></p><h3 id="三个特殊值±0、±∞、nan" tabindex="-1"><a class="header-anchor" href="#三个特殊值±0、±∞、nan"><span>三个特殊值<code>±0</code>、<code>±∞</code>、<code>NaN</code></span></a></h3><ul><li><code>±0</code>的表示</li></ul><p>如果指数是<code>0</code>并且尾数的小数部分是0，这个数<code>±0</code>（和符号位相关）</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>0 = (-1)^0 * 0 * 2^(0)</span></span>
<span class="line"><span>-0 = (-1)^1 * 0 * 2^(0)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>±∞</code>的表示</li></ul><p>如果指数 = 2^11-1并且尾数的小数部分是0，这个数是<code>±∞</code>（同样和符号位相关）</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>∞ = (-1)^0 * 0 * 2^(2047)</span></span>
<span class="line"><span>-∞ = (-1)^1 * 0 * 2^(2047)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>非数（<code>NaN</code>）</li></ul><p>如果指数 = 2^11-1并且尾数的小数部分非0，这个数表示为非数（<code>NaN</code>）</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>NaN = (-1)^0 * 1 * 2^(2047)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="javascript中number的存储" tabindex="-1"><a class="header-anchor" href="#javascript中number的存储"><span><code>JavaScript</code>中<code>Number</code>的存储</span></a></h2><p>在<code>JavaScript</code>中<code>Number</code>存储方式是<code>双精度浮点数（64位）</code>，其长度为<code>8</code>个字节，即<code>64</code>位比特。</p><h3 id="实例分析" tabindex="-1"><a class="header-anchor" href="#实例分析"><span>实例分析</span></a></h3><p>下面以<code>27.5</code>为例，存储方式如下：</p><ol><li>转换为二进制</li></ol><p>将 <code>27.5</code> 转换为二进制<code>11011.1</code>。</p><ol start="2"><li>转换为二进制科学计数法</li></ol><p><code>11011.1</code>转换为科学记数法表示为<code>-1^0 + 1.10111 * 2^4</code></p><ol start="3"><li>根据<code>IEEE 754</code>规则存储。</li></ol><p>符号位<code>S</code>为：0(表示正数，任何数的0次幂为1) 指数位<code>E</code>为：5位偏移加上双精度浮点数中指数的固定偏移量<code>1023</code>=1023+4=1027。因为它是十进制的需要转换为二进制，即 <code>10000000011</code> 尾数位<code>M</code>为：这里省略公共整数<code>1</code>为<code>10111</code>，补够52位即： <code>1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></p><p>综上所述<code>27.5</code>存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），如下：</p><p><code>0+10000000011+1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></p><h2 id="思考-疑问" tabindex="-1"><a class="header-anchor" href="#思考-疑问"><span>思考 | 疑问</span></a></h2><h3 id="javascript整数的最大值" tabindex="-1"><a class="header-anchor" href="#javascript整数的最大值"><span><code>JavaScript</code>整数的最大值</span></a></h3><p><code>JavaScript</code>中<code>Number</code>存储方式是<code>双精度浮点数（64位）</code>能表示的最大整数是<code>2 ^ 53 -1</code>。 因为整数需要连续性，所以表示整数时不能使用指数位<code>E</code>区域，只有尾数<code>M</code>区域可表示连续的数据，<code>M</code>一共占用52位，但是如果加上我们省略的首位，其实<code>M</code>最多可以表示<code>53</code>位。所以最大的安全整数是<code>2 ^ 53 -1</code>。大于 <code>9007199254740992</code> 的可能会丢失精度。<code>Number.MAX_SAFE_INTEGER</code>为<code>9007199254740991</code>。</p><h3 id="array索引既然是整数-那它的最大索引为什么不是2-53-1呢" tabindex="-1"><a class="header-anchor" href="#array索引既然是整数-那它的最大索引为什么不是2-53-1呢"><span><code>Array</code>索引既然是整数,那它的最大索引为什么不是<code>2 ^ 53 - 1</code>呢？</span></a></h3><p><code>JavaScript</code>语言中数组的索引最大就是<code>2^32 -1</code>。就当做语言规范吧，背后的原因不清楚。除了数组索引，还有其他的地方采用<code>32bit</code>整数：</p><ul><li>位运算</li><li><code>setTimeout/setInterval</code>的<code>delay</code>参数也是必须是<code>32</code>整数</li></ul><p>数组的最大长度是<code>2^32 - 1</code>，这个不是指数组只能存<code>2^32 - 1</code>位数据，也不是说数组的下标最大值就是<code>2^32 - 1</code>，而是指数组的<code>length</code>属性最大值为<code>2^32 - 1</code>。</p><p><code>ECMAScript</code> 标准约定<code>number</code>数字需要被当成 <code>64</code> 位双精度浮点数处理，但事实上，一直使用 <code>64</code> 位去存储任何数字实际是非常低效的，所以 <code>JavaScript</code> 引擎并不总会使用 <code>64</code> 位去存储数字，引擎会在内部采用其他内存表示方式，如 <code>32</code> 位。</p><h3 id="双精度浮点数-64位-指数位为什么要固定偏移1023" tabindex="-1"><a class="header-anchor" href="#双精度浮点数-64位-指数位为什么要固定偏移1023"><span><code>双精度浮点数（64位）</code>指数位为什么要固定偏移<code>1023</code></span></a></h3><p>首先要明确一点<code>E</code>的值，可能是正数也可能是负数的，对应于右移和左移。</p><p>指数部分使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（<code>64</code>位的情况是<code>1023</code>）的和。采用这种方式表示的目的是<strong>简化比较</strong>。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位<code>S</code>和<code>E</code>自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。双精度的指数部分是<code>−1022～+1023</code>加上<code>1023</code>，指数值的大小从<code>1～2046</code>（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。</p><p>浮点数阶码的偏移量就是是为了计算机处理数据的方便，还记得为什么计算机要有补码吗？使用补码原因就是希望在加法运算中将减法运算一并处理了，简化<code>CPU</code>中运算器的设计，确实我们通过补码实现了加减法的统一。现在我们将浮点数用这种形式保存，那么计算机怎么比较浮点数的大小呢？浮点数表示有两个符号位置，一个是数符<code>S</code>，一个是阶码的符号，如果仅仅采用补码作为阶码，由于阶码有正有负，整个数的符号位和阶数的符号位将导致不能进行简单的大小比较，所以阶数采用了一个无符号的正整数存储。阶数的值直接进行二进制计算，符号位置是默认为<code>0</code>的，于是阶数的值可以为<code>0</code> 到 <code>255</code></p><p>指数部分使用了偏正值形式表示后，浮点数基本上可以按照符号位、指数域、尾数域的顺序作字典比较。显然，所有正数大于负数。正负号相同时，指数的二进制表示法更大的其浮点数值更大。</p><h3 id="为什么二进制科学计数表示m会是-1-2-的浮点数" tabindex="-1"><a class="header-anchor" href="#为什么二进制科学计数表示m会是-1-2-的浮点数"><span>为什么二进制科学计数表示<code>M</code>会是<code>[1, 2)</code>的浮点数</span></a></h3><p>下面还是以<code>27.0</code>为例来说明：</p><p>之前说过<code>27.0</code>的二进制科学计数法表示为：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>1.10110 * 2^4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>其实还可以表示其他格式的，如下：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>0.110110 * 2^5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种方式虽然数学上也是一样的，但是占用的存储会不一样，比如存储<code>110110</code>比存储<code>10110</code>多用一位，5也比4大，这样就导致同样大小的内存，存放的数据不一样。 其实就是我们默认省略的<code>1</code>是一个有效信息，比省略一个首位的0，多了一个有效信息，所以<code>M</code>的值选择移位到<code>[1, 2)</code>的浮点数，其首位为必然是1。</p><p><strong>提示</strong> 我们选择二进制的指数表示时，将<code>M</code>表示为<code>1.****</code>是因为任何数都可以表示成这个格式。如果所以得值有更大的公共前缀，当然会选择这个最大的公共前缀来当整数，这样就能省略掉了。</p><p>举个例子，如果仅考虑<code>110001</code>和<code>110010</code>这两个二进制数，那我们肯定会选择下面的存储方式：</p><div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>110001 =&gt; 11.0001 * 2^4</span></span>
<span class="line"><span>M=0001</span></span>
<span class="line"><span>E=4</span></span>
<span class="line"><span></span></span>
<span class="line"><span>110010 =&gt; 11.0010 * 2^4</span></span>
<span class="line"><span>M=0010</span></span>
<span class="line"><span>E=4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样表示后，解析的时候，直接加上整数位<code>11</code>即可。</p><h3 id="指数位e为什么是11位-尾数位m才52位-偏移量用不了11啊" tabindex="-1"><a class="header-anchor" href="#指数位e为什么是11位-尾数位m才52位-偏移量用不了11啊"><span>指数位<code>E</code>为什么是<code>11</code>位，尾数位<code>M</code>才52位，偏移量用不了<code>11</code>啊</span></a></h3><p><code>单精确度（32位）</code>中有<code>8</code>位指数位，<code>23</code>位尾数位 <code>双精确度（64位）</code>中有<code>11</code>位指数位，<code>52</code>位尾数位</p><p>感觉这些尾数位，做偏移用不了这么指数位的。我能想到的是为了后面的扩展而设计的，之前还去知乎提过问，<a href="https://www.zhihu.com/question/610053140" target="_blank" rel="noopener noreferrer">IEEE754，float、double指数位为什么是8位、11位？</a>。大家有什么想法欢迎交流。</p><h3 id="_0-1-0-2-不等于-0-3的原因" tabindex="-1"><a class="header-anchor" href="#_0-1-0-2-不等于-0-3的原因"><span><code>0.1 + 0.2 不等于 0.3</code>的原因</span></a></h3><p><code>JS</code>和<code>toFixed</code>也能看到实际的值。<code>toFixed()</code> 方法可把 <code>Number</code> 四舍五入为指定小数位数的数字。</p><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740991.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">9007199254740991</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">0.1000000000000000055511151231257827021181583404541015625000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">0.2000000000000000111022302462515654042363166809082031250000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0.2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">0.3000000000000000444089209850062616169452667236328125000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0.2</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0.3</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>0.1 + 0.2 不等于 0.3</code>原因很简单，因为<code>0.1</code>存储的值比实际值大了一点，<code>0.2</code>也是大了一点（差值比<code>0.1</code>大一倍），两个相加就大很多了，多出来的就是那个尾巴，当偏移大于最小精度时就会出现误差。说到得的原因还是<code>二进制计数</code>不能精确的表示一些小数导致的。</p><h3 id="二进制计数不能精确的表示一些小数" tabindex="-1"><a class="header-anchor" href="#二进制计数不能精确的表示一些小数"><span><code>二进制计数</code>不能精确的表示一些小数</span></a></h3><p>二进制计算能精确表示的小数肯定是能够通过不断乘以2的到结果为1的数的和，比如<code>0.5</code>、<code>0.25</code>、<code>0.125</code>等。不能精确表示<code>0.1</code>之类的数。</p><p>为什么<code>0.1</code>不能够被准确存储呢？因为计算机都是二进制的，在十进制能表示的数不一定能被二进制精确表示，就好像在十进制里面无法准确表示<code>1/3</code>一样，而在三进制里面<code>0.1</code>便表示<code>1/3</code>了。 在二进制里面能够被精确表示都必须得是二的倍数的组合，如二进制的<code>0.1</code>表示十进制的<code>0.5</code>，<code>0.11</code>便表示<code>0.75（0.5 + 0.25）</code>，<code>0.111</code>表示<code>0.875（0.5 + 0.25 + 0.125）</code>，假设现在要存储<code>0.625</code>那么能够被精确表示为二进制的<code>0.101</code>，如果要表示<code>0.626</code>呢？那么应该是通过后面的小数位相加拼凑，让其尽可能逼近<code>0.626</code>. 这个时候就不是精确表示了，这个事情就是编译器的工作。</p><p><strong>提示</strong> 这里所说的最小表示精度，是有尾数位<code>M</code>的大小决定的</p><h3 id="javascript大数问题解决" tabindex="-1"><a class="header-anchor" href="#javascript大数问题解决"><span><code>JavaScript</code>大数问题解决</span></a></h3><p>下面等式成立</p><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ===</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>超出了最大安全范围</p><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740992.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740992.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740994.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740996.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740996.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 6</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740996.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Number</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">MAX_SAFE_INTEGER </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">toFixed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">9007199254740998.0000000000000000000000000000000000000000000000000000000000000000</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了处理超过整数最大安全范围的数字，需要考虑其他方案。</p><ul><li><code>decimal.js</code> 字符串的形式计算，以性能换精度。</li><li><code>BigInt</code> 新类型，字符串<code>n</code>结尾，如：<code>9007199254740993n</code></li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener noreferrer">IEEE 754</a></p><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" target="_blank" rel="noopener noreferrer">IEEE 754 Converter （在线查看）</a></p><p><a href="https://www.zhihu.com/question/610053140" target="_blank" rel="noopener noreferrer">IEEE754，float、double指数位为什么是8位、11位？</a></p><p><a href="https://blog.csdn.net/weixin_39786850/article/details/110746250" target="_blank" rel="noopener noreferrer">JS Number精度</a></p><p><a href="https://www.zhihu.com/question/21711083/answer/63951385" target="_blank" rel="noopener noreferrer">计算机编程语言中里有提到浮点类型float和double采用了IEEE754格式有参考价值</a></p>`,121)]))}const h=e(l,[["render",c],["__file","38rd8vft.html.vue"]]),r=JSON.parse('{"path":"/article/38rd8vft.html","title":"JavaScript Number精度","lang":"zh-CN","frontmatter":{"title":"JavaScript Number精度","createTime":"2025/01/09 19:02:12","permalink":"/article/38rd8vft.html","sticky":1,"tags":["JavaScript","IEEE754"],"watermark":true},"headers":[],"readingTime":{"minutes":14.1,"words":4229},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"javascript/Number精度.md","categoryList":[{"id":"de9b9e","sort":10041,"name":"javascript"}],"bulletin":false}');export{h as comp,r as data};
