import{_ as t,c as e,a as s,o as l}from"./app-CS9K37Kg.js";const i={};function n(d,a){return l(),e("div",null,a[0]||(a[0]=[s(`<p>Macvlan 是 Linux 内核中的一种 网络虚拟化技术，用于在一个物理网卡上创建多个虚拟网卡，每个都有独立的 MAC 地址。</p><h2 id="macvlan-的主要用途" tabindex="-1"><a class="header-anchor" href="#macvlan-的主要用途"><span>Macvlan 的主要用途</span></a></h2><ul><li>让多个容器/虚拟机共享同一张物理网卡，每个容器/虚拟机都像独立的主机。</li><li>给 Docker 容器分配独立 IP，让它们像物理机一样直接与外部网络通信。</li><li>解决传统桥接网络（Bridge）模式的限制，提高网络性能。</li><li>适用于嵌入式系统或 IoT 设备，可以将多个应用绑定到同一网卡，但使用不同的 MAC 地址。</li></ul><h2 id="macvlan-主要模式" tabindex="-1"><a class="header-anchor" href="#macvlan-主要模式"><span>Macvlan 主要模式</span></a></h2><p>Macvlan 提供了 四种模式，影响数据包如何流动：</p><p>模式 说明 适用场景 bridge（默认） 和物理网卡桥接，像交换机一样，每个虚拟设备有独立 IP 多个容器/VM 直接访问局域网 private 只能与相同 macvlan 网络中的设备通信，不能访问外网 内部隔离的安全环境 vepa 数据包必须通过物理交换机转发，类似 VLAN 需要物理交换机支持 passthru 只有一个 MAC 地址，直接使用物理网卡 类似网卡直通，通常用于 VM</p><h2 id="macvlan-在-docker-中的应用" tabindex="-1"><a class="header-anchor" href="#macvlan-在-docker-中的应用"><span>Macvlan 在 Docker 中的应用</span></a></h2><p>Macvlan 适用于 Docker，可以让容器像真实服务器一样拥有独立 IP：</p><h3 id="创建-macvlan-网络" tabindex="-1"><a class="header-anchor" href="#创建-macvlan-网络"><span>创建 Macvlan 网络</span></a></h3><div class="language-yml line-numbers-mode" data-ext="yml" data-title="yml"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">docker network create -d macvlan \\</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  --subnet=192.168.1.0/24 \\</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  --gateway=192.168.1.1 \\</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  -o parent=eth0 \\</span></span>
<span class="line"><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  my_macvlan</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这里 eth0 是宿主机的网卡。</li></ul><h3 id="运行容器并使用-macvlan-网络" tabindex="-1"><a class="header-anchor" href="#运行容器并使用-macvlan-网络"><span>运行容器并使用 Macvlan 网络</span></a></h3><div class="language-sh line-numbers-mode" data-ext="sh" data-title="sh"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -it</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --rm</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --network</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> my_macvlan</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --ip</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 192.168.1.100</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> nginx</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样，容器 nginx 就有了 192.168.1.100 的 IP，外部设备可以直接访问它。</p><h2 id="macvlan-vs-其他-docker-网络" tabindex="-1"><a class="header-anchor" href="#macvlan-vs-其他-docker-网络"><span>Macvlan vs 其他 Docker 网络</span></a></h2><table><thead><tr><th style="text-align:left;">网络模式</th><th style="text-align:left;">特点</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;">Bridge（默认）</td><td style="text-align:left;">通过 NAT 访问外网，IP 由 Docker 分配</td><td style="text-align:left;">容器内部互通，但访问宿主机有额外配置</td></tr><tr><td style="text-align:left;">Host</td><td style="text-align:left;">容器使用宿主机 IP，无额外网络隔离</td><td style="text-align:left;">需要与宿主机共享 IP 的情况</td></tr><tr><td style="text-align:left;">Macvlan</td><td style="text-align:left;">容器拥有独立 IP，可直接访问局域网</td><td style="text-align:left;">适用于与物理网络无缝通信的情况</td></tr><tr><td style="text-align:left;">Overlay</td><td style="text-align:left;">跨主机容器通信（Swarm、Kubernetes）</td><td style="text-align:left;">分布式集群</td></tr></tbody></table><h2 id="macvlan-适合的场景" tabindex="-1"><a class="header-anchor" href="#macvlan-适合的场景"><span>Macvlan 适合的场景</span></a></h2><ul><li>你希望容器有独立 IP，直接与局域网设备通信（如数据库、物联网设备）。</li><li>你想在一台物理机上运行多个服务，每个服务像真实主机一样独立。</li><li>你不想使用端口映射，希望容器和普通设备一样访问网络。</li></ul><h2 id="macvlan-不适合的场景" tabindex="-1"><a class="header-anchor" href="#macvlan-不适合的场景"><span>Macvlan 不适合的场景</span></a></h2><ul><li>宿主机本身不能访问 macvlan 容器（除非创建额外的 macvlan 设备）。</li><li>需要在 NAT 下运行（例如云服务器），因为 Macvlan 需要物理网卡。</li></ul><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>Macvlan 适用于高级网络管理，让容器/虚拟机像真实设备一样存在于网络中，但配置稍复杂，适用于对网络要求较高的场景（如物联网、数据库集群、企业内网服务）。</p>`,22)]))}const c=t(i,[["render",n],["__file","wlw4fwtf.html.vue"]]),h=JSON.parse('{"path":"/nas/wlw4fwtf.html","title":"macvlan","lang":"zh-CN","frontmatter":{"title":"macvlan","createTime":"2025/02/26 17:13:40","permalink":"/nas/wlw4fwtf.html","watermark":true},"headers":[],"readingTime":{"minutes":2.58,"words":775},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/nas/macvlan.md","bulletin":false}');export{c as comp,h as data};
