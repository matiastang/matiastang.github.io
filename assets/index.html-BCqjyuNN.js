import{_ as t,c as a,a as r,o as n}from"./app-CS9K37Kg.js";const i={};function o(s,e){return n(),a("div",null,e[0]||(e[0]=[r('<h1 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h1><p>四种异步方法：（发展历程）</p><p>1.callback回调函数</p><p>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</p><p>优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）</p><p>2.Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p><p>优点：解决了回调地狱的问题 缺点：无法取消 Promise ，错误需要通过回调函数来捕获</p><p>3.generator 可以控制函数的执行，可以配合 co 函数库使用</p><p>// 惰性执行 yield 配合 next() function * xxx () { let id = 1 while (true) { yield id++ } const idMaker = xxx() idMaker.next().value } 4.async 和 await 其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator</p><p>async function () { const user = await ajax(&#39;/api/user.json&#39;) } 优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p><p>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低</p>',11)]))}const p=t(i,[["render",o],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/article/tmotnysx/","title":"异步","lang":"zh-CN","frontmatter":{"title":"异步","createTime":"2025/01/21 15:07:46","permalink":"/article/tmotnysx/","watermark":true},"headers":[],"readingTime":{"minutes":1.09,"words":328},"git":{"updatedTime":1755670488000,"contributors":[{"name":"唐道勇","username":"唐道勇","email":"matias@tangdaoyongdeMacBook-Pro.local","commits":1,"avatar":"https://avatars.githubusercontent.com/唐道勇?v=4","url":"https://github.com/唐道勇"}]},"filePathRelative":"notes/interview/异步.md","categoryList":[{"id":"4358b5","sort":10000,"name":"notes"},{"id":"fe1bf4","sort":10002,"name":"interview"}],"bulletin":false}');export{p as comp,m as data};
